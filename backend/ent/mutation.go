// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team18/app/ent/checkin"
	"github.com/team18/app/ent/checkout"
	"github.com/team18/app/ent/counterstaff"
	"github.com/team18/app/ent/customer"
	"github.com/team18/app/ent/dataroom"
	"github.com/team18/app/ent/fixroom"
	"github.com/team18/app/ent/furniture"
	"github.com/team18/app/ent/furnituredetail"
	"github.com/team18/app/ent/furnituretype"
	"github.com/team18/app/ent/promotion"
	"github.com/team18/app/ent/reserveroom"
	"github.com/team18/app/ent/status"
	"github.com/team18/app/ent/statusroom"
	"github.com/team18/app/ent/typeroom"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCheckIn         = "CheckIn"
	TypeCheckout        = "Checkout"
	TypeCounterStaff    = "CounterStaff"
	TypeCustomer        = "Customer"
	TypeDataRoom        = "DataRoom"
	TypeFixRoom         = "FixRoom"
	TypeFurniture       = "Furniture"
	TypeFurnitureDetail = "FurnitureDetail"
	TypeFurnitureType   = "FurnitureType"
	TypePromotion       = "Promotion"
	TypeReserveRoom     = "ReserveRoom"
	TypeStatus          = "Status"
	TypeStatusRoom      = "StatusRoom"
	TypeTypeRoom        = "TypeRoom"
)

// CheckInMutation represents an operation that mutate the CheckIns
// nodes in the graph.
type CheckInMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	checkin_date       *time.Time
	clearedFields      map[string]struct{}
	customer           *int
	clearedcustomer    bool
	counter            *int
	clearedcounter     bool
	reserveroom        *int
	clearedreserveroom bool
	dataroom           *int
	cleareddataroom    bool
	checkouts          *int
	clearedcheckouts   bool
	done               bool
	oldValue           func(context.Context) (*CheckIn, error)
}

var _ ent.Mutation = (*CheckInMutation)(nil)

// checkinOption allows to manage the mutation configuration using functional options.
type checkinOption func(*CheckInMutation)

// newCheckInMutation creates new mutation for $n.Name.
func newCheckInMutation(c config, op Op, opts ...checkinOption) *CheckInMutation {
	m := &CheckInMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckIn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckInID sets the id field of the mutation.
func withCheckInID(id int) checkinOption {
	return func(m *CheckInMutation) {
		var (
			err   error
			once  sync.Once
			value *CheckIn
		)
		m.oldValue = func(ctx context.Context) (*CheckIn, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CheckIn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckIn sets the old CheckIn of the mutation.
func withCheckIn(node *CheckIn) checkinOption {
	return func(m *CheckInMutation) {
		m.oldValue = func(context.Context) (*CheckIn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckInMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckInMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CheckInMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCheckinDate sets the checkin_date field.
func (m *CheckInMutation) SetCheckinDate(t time.Time) {
	m.checkin_date = &t
}

// CheckinDate returns the checkin_date value in the mutation.
func (m *CheckInMutation) CheckinDate() (r time.Time, exists bool) {
	v := m.checkin_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckinDate returns the old checkin_date value of the CheckIn.
// If the CheckIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckInMutation) OldCheckinDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckinDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckinDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckinDate: %w", err)
	}
	return oldValue.CheckinDate, nil
}

// ResetCheckinDate reset all changes of the "checkin_date" field.
func (m *CheckInMutation) ResetCheckinDate() {
	m.checkin_date = nil
}

// SetCustomerID sets the customer edge to Customer by id.
func (m *CheckInMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the customer edge to Customer.
func (m *CheckInMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared returns if the edge customer was cleared.
func (m *CheckInMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the customer id in the mutation.
func (m *CheckInMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the customer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CheckInMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer reset all changes of the "customer" edge.
func (m *CheckInMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetCounterID sets the counter edge to CounterStaff by id.
func (m *CheckInMutation) SetCounterID(id int) {
	m.counter = &id
}

// ClearCounter clears the counter edge to CounterStaff.
func (m *CheckInMutation) ClearCounter() {
	m.clearedcounter = true
}

// CounterCleared returns if the edge counter was cleared.
func (m *CheckInMutation) CounterCleared() bool {
	return m.clearedcounter
}

// CounterID returns the counter id in the mutation.
func (m *CheckInMutation) CounterID() (id int, exists bool) {
	if m.counter != nil {
		return *m.counter, true
	}
	return
}

// CounterIDs returns the counter ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CounterID instead. It exists only for internal usage by the builders.
func (m *CheckInMutation) CounterIDs() (ids []int) {
	if id := m.counter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCounter reset all changes of the "counter" edge.
func (m *CheckInMutation) ResetCounter() {
	m.counter = nil
	m.clearedcounter = false
}

// SetReserveroomID sets the reserveroom edge to ReserveRoom by id.
func (m *CheckInMutation) SetReserveroomID(id int) {
	m.reserveroom = &id
}

// ClearReserveroom clears the reserveroom edge to ReserveRoom.
func (m *CheckInMutation) ClearReserveroom() {
	m.clearedreserveroom = true
}

// ReserveroomCleared returns if the edge reserveroom was cleared.
func (m *CheckInMutation) ReserveroomCleared() bool {
	return m.clearedreserveroom
}

// ReserveroomID returns the reserveroom id in the mutation.
func (m *CheckInMutation) ReserveroomID() (id int, exists bool) {
	if m.reserveroom != nil {
		return *m.reserveroom, true
	}
	return
}

// ReserveroomIDs returns the reserveroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ReserveroomID instead. It exists only for internal usage by the builders.
func (m *CheckInMutation) ReserveroomIDs() (ids []int) {
	if id := m.reserveroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReserveroom reset all changes of the "reserveroom" edge.
func (m *CheckInMutation) ResetReserveroom() {
	m.reserveroom = nil
	m.clearedreserveroom = false
}

// SetDataroomID sets the dataroom edge to DataRoom by id.
func (m *CheckInMutation) SetDataroomID(id int) {
	m.dataroom = &id
}

// ClearDataroom clears the dataroom edge to DataRoom.
func (m *CheckInMutation) ClearDataroom() {
	m.cleareddataroom = true
}

// DataroomCleared returns if the edge dataroom was cleared.
func (m *CheckInMutation) DataroomCleared() bool {
	return m.cleareddataroom
}

// DataroomID returns the dataroom id in the mutation.
func (m *CheckInMutation) DataroomID() (id int, exists bool) {
	if m.dataroom != nil {
		return *m.dataroom, true
	}
	return
}

// DataroomIDs returns the dataroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DataroomID instead. It exists only for internal usage by the builders.
func (m *CheckInMutation) DataroomIDs() (ids []int) {
	if id := m.dataroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDataroom reset all changes of the "dataroom" edge.
func (m *CheckInMutation) ResetDataroom() {
	m.dataroom = nil
	m.cleareddataroom = false
}

// SetCheckoutsID sets the checkouts edge to Checkout by id.
func (m *CheckInMutation) SetCheckoutsID(id int) {
	m.checkouts = &id
}

// ClearCheckouts clears the checkouts edge to Checkout.
func (m *CheckInMutation) ClearCheckouts() {
	m.clearedcheckouts = true
}

// CheckoutsCleared returns if the edge checkouts was cleared.
func (m *CheckInMutation) CheckoutsCleared() bool {
	return m.clearedcheckouts
}

// CheckoutsID returns the checkouts id in the mutation.
func (m *CheckInMutation) CheckoutsID() (id int, exists bool) {
	if m.checkouts != nil {
		return *m.checkouts, true
	}
	return
}

// CheckoutsIDs returns the checkouts ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CheckoutsID instead. It exists only for internal usage by the builders.
func (m *CheckInMutation) CheckoutsIDs() (ids []int) {
	if id := m.checkouts; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCheckouts reset all changes of the "checkouts" edge.
func (m *CheckInMutation) ResetCheckouts() {
	m.checkouts = nil
	m.clearedcheckouts = false
}

// Op returns the operation name.
func (m *CheckInMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CheckIn).
func (m *CheckInMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CheckInMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.checkin_date != nil {
		fields = append(fields, checkin.FieldCheckinDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CheckInMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checkin.FieldCheckinDate:
		return m.CheckinDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CheckInMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checkin.FieldCheckinDate:
		return m.OldCheckinDate(ctx)
	}
	return nil, fmt.Errorf("unknown CheckIn field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckInMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checkin.FieldCheckinDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckinDate(v)
		return nil
	}
	return fmt.Errorf("unknown CheckIn field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CheckInMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CheckInMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckInMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CheckIn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CheckInMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CheckInMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckInMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CheckIn nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CheckInMutation) ResetField(name string) error {
	switch name {
	case checkin.FieldCheckinDate:
		m.ResetCheckinDate()
		return nil
	}
	return fmt.Errorf("unknown CheckIn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CheckInMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.customer != nil {
		edges = append(edges, checkin.EdgeCustomer)
	}
	if m.counter != nil {
		edges = append(edges, checkin.EdgeCounter)
	}
	if m.reserveroom != nil {
		edges = append(edges, checkin.EdgeReserveroom)
	}
	if m.dataroom != nil {
		edges = append(edges, checkin.EdgeDataroom)
	}
	if m.checkouts != nil {
		edges = append(edges, checkin.EdgeCheckouts)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CheckInMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checkin.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case checkin.EdgeCounter:
		if id := m.counter; id != nil {
			return []ent.Value{*id}
		}
	case checkin.EdgeReserveroom:
		if id := m.reserveroom; id != nil {
			return []ent.Value{*id}
		}
	case checkin.EdgeDataroom:
		if id := m.dataroom; id != nil {
			return []ent.Value{*id}
		}
	case checkin.EdgeCheckouts:
		if id := m.checkouts; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CheckInMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CheckInMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CheckInMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcustomer {
		edges = append(edges, checkin.EdgeCustomer)
	}
	if m.clearedcounter {
		edges = append(edges, checkin.EdgeCounter)
	}
	if m.clearedreserveroom {
		edges = append(edges, checkin.EdgeReserveroom)
	}
	if m.cleareddataroom {
		edges = append(edges, checkin.EdgeDataroom)
	}
	if m.clearedcheckouts {
		edges = append(edges, checkin.EdgeCheckouts)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CheckInMutation) EdgeCleared(name string) bool {
	switch name {
	case checkin.EdgeCustomer:
		return m.clearedcustomer
	case checkin.EdgeCounter:
		return m.clearedcounter
	case checkin.EdgeReserveroom:
		return m.clearedreserveroom
	case checkin.EdgeDataroom:
		return m.cleareddataroom
	case checkin.EdgeCheckouts:
		return m.clearedcheckouts
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CheckInMutation) ClearEdge(name string) error {
	switch name {
	case checkin.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case checkin.EdgeCounter:
		m.ClearCounter()
		return nil
	case checkin.EdgeReserveroom:
		m.ClearReserveroom()
		return nil
	case checkin.EdgeDataroom:
		m.ClearDataroom()
		return nil
	case checkin.EdgeCheckouts:
		m.ClearCheckouts()
		return nil
	}
	return fmt.Errorf("unknown CheckIn unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CheckInMutation) ResetEdge(name string) error {
	switch name {
	case checkin.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case checkin.EdgeCounter:
		m.ResetCounter()
		return nil
	case checkin.EdgeReserveroom:
		m.ResetReserveroom()
		return nil
	case checkin.EdgeDataroom:
		m.ResetDataroom()
		return nil
	case checkin.EdgeCheckouts:
		m.ResetCheckouts()
		return nil
	}
	return fmt.Errorf("unknown CheckIn edge %s", name)
}

// CheckoutMutation represents an operation that mutate the Checkouts
// nodes in the graph.
type CheckoutMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	checkout_date        *time.Time
	clearedFields        map[string]struct{}
	statuss              *int
	clearedstatuss       bool
	counterstaffs        *int
	clearedcounterstaffs bool
	checkins             *int
	clearedcheckins      bool
	done                 bool
	oldValue             func(context.Context) (*Checkout, error)
}

var _ ent.Mutation = (*CheckoutMutation)(nil)

// checkoutOption allows to manage the mutation configuration using functional options.
type checkoutOption func(*CheckoutMutation)

// newCheckoutMutation creates new mutation for $n.Name.
func newCheckoutMutation(c config, op Op, opts ...checkoutOption) *CheckoutMutation {
	m := &CheckoutMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckout,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckoutID sets the id field of the mutation.
func withCheckoutID(id int) checkoutOption {
	return func(m *CheckoutMutation) {
		var (
			err   error
			once  sync.Once
			value *Checkout
		)
		m.oldValue = func(ctx context.Context) (*Checkout, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Checkout.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckout sets the old Checkout of the mutation.
func withCheckout(node *Checkout) checkoutOption {
	return func(m *CheckoutMutation) {
		m.oldValue = func(context.Context) (*Checkout, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckoutMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckoutMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CheckoutMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCheckoutDate sets the checkout_date field.
func (m *CheckoutMutation) SetCheckoutDate(t time.Time) {
	m.checkout_date = &t
}

// CheckoutDate returns the checkout_date value in the mutation.
func (m *CheckoutMutation) CheckoutDate() (r time.Time, exists bool) {
	v := m.checkout_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckoutDate returns the old checkout_date value of the Checkout.
// If the Checkout object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckoutMutation) OldCheckoutDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckoutDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckoutDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckoutDate: %w", err)
	}
	return oldValue.CheckoutDate, nil
}

// ResetCheckoutDate reset all changes of the "checkout_date" field.
func (m *CheckoutMutation) ResetCheckoutDate() {
	m.checkout_date = nil
}

// SetStatussID sets the statuss edge to Status by id.
func (m *CheckoutMutation) SetStatussID(id int) {
	m.statuss = &id
}

// ClearStatuss clears the statuss edge to Status.
func (m *CheckoutMutation) ClearStatuss() {
	m.clearedstatuss = true
}

// StatussCleared returns if the edge statuss was cleared.
func (m *CheckoutMutation) StatussCleared() bool {
	return m.clearedstatuss
}

// StatussID returns the statuss id in the mutation.
func (m *CheckoutMutation) StatussID() (id int, exists bool) {
	if m.statuss != nil {
		return *m.statuss, true
	}
	return
}

// StatussIDs returns the statuss ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatussID instead. It exists only for internal usage by the builders.
func (m *CheckoutMutation) StatussIDs() (ids []int) {
	if id := m.statuss; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatuss reset all changes of the "statuss" edge.
func (m *CheckoutMutation) ResetStatuss() {
	m.statuss = nil
	m.clearedstatuss = false
}

// SetCounterstaffsID sets the counterstaffs edge to CounterStaff by id.
func (m *CheckoutMutation) SetCounterstaffsID(id int) {
	m.counterstaffs = &id
}

// ClearCounterstaffs clears the counterstaffs edge to CounterStaff.
func (m *CheckoutMutation) ClearCounterstaffs() {
	m.clearedcounterstaffs = true
}

// CounterstaffsCleared returns if the edge counterstaffs was cleared.
func (m *CheckoutMutation) CounterstaffsCleared() bool {
	return m.clearedcounterstaffs
}

// CounterstaffsID returns the counterstaffs id in the mutation.
func (m *CheckoutMutation) CounterstaffsID() (id int, exists bool) {
	if m.counterstaffs != nil {
		return *m.counterstaffs, true
	}
	return
}

// CounterstaffsIDs returns the counterstaffs ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CounterstaffsID instead. It exists only for internal usage by the builders.
func (m *CheckoutMutation) CounterstaffsIDs() (ids []int) {
	if id := m.counterstaffs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCounterstaffs reset all changes of the "counterstaffs" edge.
func (m *CheckoutMutation) ResetCounterstaffs() {
	m.counterstaffs = nil
	m.clearedcounterstaffs = false
}

// SetCheckinsID sets the checkins edge to CheckIn by id.
func (m *CheckoutMutation) SetCheckinsID(id int) {
	m.checkins = &id
}

// ClearCheckins clears the checkins edge to CheckIn.
func (m *CheckoutMutation) ClearCheckins() {
	m.clearedcheckins = true
}

// CheckinsCleared returns if the edge checkins was cleared.
func (m *CheckoutMutation) CheckinsCleared() bool {
	return m.clearedcheckins
}

// CheckinsID returns the checkins id in the mutation.
func (m *CheckoutMutation) CheckinsID() (id int, exists bool) {
	if m.checkins != nil {
		return *m.checkins, true
	}
	return
}

// CheckinsIDs returns the checkins ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CheckinsID instead. It exists only for internal usage by the builders.
func (m *CheckoutMutation) CheckinsIDs() (ids []int) {
	if id := m.checkins; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCheckins reset all changes of the "checkins" edge.
func (m *CheckoutMutation) ResetCheckins() {
	m.checkins = nil
	m.clearedcheckins = false
}

// Op returns the operation name.
func (m *CheckoutMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Checkout).
func (m *CheckoutMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CheckoutMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.checkout_date != nil {
		fields = append(fields, checkout.FieldCheckoutDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CheckoutMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checkout.FieldCheckoutDate:
		return m.CheckoutDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CheckoutMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checkout.FieldCheckoutDate:
		return m.OldCheckoutDate(ctx)
	}
	return nil, fmt.Errorf("unknown Checkout field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckoutMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checkout.FieldCheckoutDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckoutDate(v)
		return nil
	}
	return fmt.Errorf("unknown Checkout field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CheckoutMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CheckoutMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckoutMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Checkout numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CheckoutMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CheckoutMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckoutMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Checkout nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CheckoutMutation) ResetField(name string) error {
	switch name {
	case checkout.FieldCheckoutDate:
		m.ResetCheckoutDate()
		return nil
	}
	return fmt.Errorf("unknown Checkout field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CheckoutMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.statuss != nil {
		edges = append(edges, checkout.EdgeStatuss)
	}
	if m.counterstaffs != nil {
		edges = append(edges, checkout.EdgeCounterstaffs)
	}
	if m.checkins != nil {
		edges = append(edges, checkout.EdgeCheckins)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CheckoutMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checkout.EdgeStatuss:
		if id := m.statuss; id != nil {
			return []ent.Value{*id}
		}
	case checkout.EdgeCounterstaffs:
		if id := m.counterstaffs; id != nil {
			return []ent.Value{*id}
		}
	case checkout.EdgeCheckins:
		if id := m.checkins; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CheckoutMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CheckoutMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CheckoutMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedstatuss {
		edges = append(edges, checkout.EdgeStatuss)
	}
	if m.clearedcounterstaffs {
		edges = append(edges, checkout.EdgeCounterstaffs)
	}
	if m.clearedcheckins {
		edges = append(edges, checkout.EdgeCheckins)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CheckoutMutation) EdgeCleared(name string) bool {
	switch name {
	case checkout.EdgeStatuss:
		return m.clearedstatuss
	case checkout.EdgeCounterstaffs:
		return m.clearedcounterstaffs
	case checkout.EdgeCheckins:
		return m.clearedcheckins
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CheckoutMutation) ClearEdge(name string) error {
	switch name {
	case checkout.EdgeStatuss:
		m.ClearStatuss()
		return nil
	case checkout.EdgeCounterstaffs:
		m.ClearCounterstaffs()
		return nil
	case checkout.EdgeCheckins:
		m.ClearCheckins()
		return nil
	}
	return fmt.Errorf("unknown Checkout unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CheckoutMutation) ResetEdge(name string) error {
	switch name {
	case checkout.EdgeStatuss:
		m.ResetStatuss()
		return nil
	case checkout.EdgeCounterstaffs:
		m.ResetCounterstaffs()
		return nil
	case checkout.EdgeCheckins:
		m.ResetCheckins()
		return nil
	}
	return fmt.Errorf("unknown Checkout edge %s", name)
}

// CounterStaffMutation represents an operation that mutate the CounterStaffs
// nodes in the graph.
type CounterStaffMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	email            *string
	password         *string
	clearedFields    map[string]struct{}
	checkins         map[int]struct{}
	removedcheckins  map[int]struct{}
	checkouts        map[int]struct{}
	removedcheckouts map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*CounterStaff, error)
}

var _ ent.Mutation = (*CounterStaffMutation)(nil)

// counterstaffOption allows to manage the mutation configuration using functional options.
type counterstaffOption func(*CounterStaffMutation)

// newCounterStaffMutation creates new mutation for $n.Name.
func newCounterStaffMutation(c config, op Op, opts ...counterstaffOption) *CounterStaffMutation {
	m := &CounterStaffMutation{
		config:        c,
		op:            op,
		typ:           TypeCounterStaff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCounterStaffID sets the id field of the mutation.
func withCounterStaffID(id int) counterstaffOption {
	return func(m *CounterStaffMutation) {
		var (
			err   error
			once  sync.Once
			value *CounterStaff
		)
		m.oldValue = func(ctx context.Context) (*CounterStaff, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CounterStaff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCounterStaff sets the old CounterStaff of the mutation.
func withCounterStaff(node *CounterStaff) counterstaffOption {
	return func(m *CounterStaffMutation) {
		m.oldValue = func(context.Context) (*CounterStaff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CounterStaffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CounterStaffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CounterStaffMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CounterStaffMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CounterStaffMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CounterStaff.
// If the CounterStaff object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterStaffMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CounterStaffMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *CounterStaffMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *CounterStaffMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the CounterStaff.
// If the CounterStaff object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterStaffMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *CounterStaffMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *CounterStaffMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *CounterStaffMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the CounterStaff.
// If the CounterStaff object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterStaffMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *CounterStaffMutation) ResetPassword() {
	m.password = nil
}

// AddCheckinIDs adds the checkins edge to CheckIn by ids.
func (m *CounterStaffMutation) AddCheckinIDs(ids ...int) {
	if m.checkins == nil {
		m.checkins = make(map[int]struct{})
	}
	for i := range ids {
		m.checkins[ids[i]] = struct{}{}
	}
}

// RemoveCheckinIDs removes the checkins edge to CheckIn by ids.
func (m *CounterStaffMutation) RemoveCheckinIDs(ids ...int) {
	if m.removedcheckins == nil {
		m.removedcheckins = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheckins[ids[i]] = struct{}{}
	}
}

// RemovedCheckins returns the removed ids of checkins.
func (m *CounterStaffMutation) RemovedCheckinsIDs() (ids []int) {
	for id := range m.removedcheckins {
		ids = append(ids, id)
	}
	return
}

// CheckinsIDs returns the checkins ids in the mutation.
func (m *CounterStaffMutation) CheckinsIDs() (ids []int) {
	for id := range m.checkins {
		ids = append(ids, id)
	}
	return
}

// ResetCheckins reset all changes of the "checkins" edge.
func (m *CounterStaffMutation) ResetCheckins() {
	m.checkins = nil
	m.removedcheckins = nil
}

// AddCheckoutIDs adds the checkouts edge to Checkout by ids.
func (m *CounterStaffMutation) AddCheckoutIDs(ids ...int) {
	if m.checkouts == nil {
		m.checkouts = make(map[int]struct{})
	}
	for i := range ids {
		m.checkouts[ids[i]] = struct{}{}
	}
}

// RemoveCheckoutIDs removes the checkouts edge to Checkout by ids.
func (m *CounterStaffMutation) RemoveCheckoutIDs(ids ...int) {
	if m.removedcheckouts == nil {
		m.removedcheckouts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheckouts[ids[i]] = struct{}{}
	}
}

// RemovedCheckouts returns the removed ids of checkouts.
func (m *CounterStaffMutation) RemovedCheckoutsIDs() (ids []int) {
	for id := range m.removedcheckouts {
		ids = append(ids, id)
	}
	return
}

// CheckoutsIDs returns the checkouts ids in the mutation.
func (m *CounterStaffMutation) CheckoutsIDs() (ids []int) {
	for id := range m.checkouts {
		ids = append(ids, id)
	}
	return
}

// ResetCheckouts reset all changes of the "checkouts" edge.
func (m *CounterStaffMutation) ResetCheckouts() {
	m.checkouts = nil
	m.removedcheckouts = nil
}

// Op returns the operation name.
func (m *CounterStaffMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CounterStaff).
func (m *CounterStaffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CounterStaffMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, counterstaff.FieldName)
	}
	if m.email != nil {
		fields = append(fields, counterstaff.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, counterstaff.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CounterStaffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case counterstaff.FieldName:
		return m.Name()
	case counterstaff.FieldEmail:
		return m.Email()
	case counterstaff.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CounterStaffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case counterstaff.FieldName:
		return m.OldName(ctx)
	case counterstaff.FieldEmail:
		return m.OldEmail(ctx)
	case counterstaff.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown CounterStaff field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CounterStaffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case counterstaff.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case counterstaff.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case counterstaff.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown CounterStaff field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CounterStaffMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CounterStaffMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CounterStaffMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CounterStaff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CounterStaffMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CounterStaffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CounterStaffMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CounterStaff nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CounterStaffMutation) ResetField(name string) error {
	switch name {
	case counterstaff.FieldName:
		m.ResetName()
		return nil
	case counterstaff.FieldEmail:
		m.ResetEmail()
		return nil
	case counterstaff.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown CounterStaff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CounterStaffMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.checkins != nil {
		edges = append(edges, counterstaff.EdgeCheckins)
	}
	if m.checkouts != nil {
		edges = append(edges, counterstaff.EdgeCheckouts)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CounterStaffMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case counterstaff.EdgeCheckins:
		ids := make([]ent.Value, 0, len(m.checkins))
		for id := range m.checkins {
			ids = append(ids, id)
		}
		return ids
	case counterstaff.EdgeCheckouts:
		ids := make([]ent.Value, 0, len(m.checkouts))
		for id := range m.checkouts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CounterStaffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcheckins != nil {
		edges = append(edges, counterstaff.EdgeCheckins)
	}
	if m.removedcheckouts != nil {
		edges = append(edges, counterstaff.EdgeCheckouts)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CounterStaffMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case counterstaff.EdgeCheckins:
		ids := make([]ent.Value, 0, len(m.removedcheckins))
		for id := range m.removedcheckins {
			ids = append(ids, id)
		}
		return ids
	case counterstaff.EdgeCheckouts:
		ids := make([]ent.Value, 0, len(m.removedcheckouts))
		for id := range m.removedcheckouts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CounterStaffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CounterStaffMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CounterStaffMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CounterStaff unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CounterStaffMutation) ResetEdge(name string) error {
	switch name {
	case counterstaff.EdgeCheckins:
		m.ResetCheckins()
		return nil
	case counterstaff.EdgeCheckouts:
		m.ResetCheckouts()
		return nil
	}
	return fmt.Errorf("unknown CounterStaff edge %s", name)
}

// CustomerMutation represents an operation that mutate the Customers
// nodes in the graph.
type CustomerMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	email           *string
	password        *string
	clearedFields   map[string]struct{}
	reserves        map[int]struct{}
	removedreserves map[int]struct{}
	fixs            map[int]struct{}
	removedfixs     map[int]struct{}
	checkins        map[int]struct{}
	removedcheckins map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Customer, error)
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows to manage the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for $n.Name.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the id field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *CustomerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *CustomerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *CustomerMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *CustomerMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *CustomerMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *CustomerMutation) ResetPassword() {
	m.password = nil
}

// AddReserfIDs adds the reserves edge to ReserveRoom by ids.
func (m *CustomerMutation) AddReserfIDs(ids ...int) {
	if m.reserves == nil {
		m.reserves = make(map[int]struct{})
	}
	for i := range ids {
		m.reserves[ids[i]] = struct{}{}
	}
}

// RemoveReserfIDs removes the reserves edge to ReserveRoom by ids.
func (m *CustomerMutation) RemoveReserfIDs(ids ...int) {
	if m.removedreserves == nil {
		m.removedreserves = make(map[int]struct{})
	}
	for i := range ids {
		m.removedreserves[ids[i]] = struct{}{}
	}
}

// RemovedReserves returns the removed ids of reserves.
func (m *CustomerMutation) RemovedReservesIDs() (ids []int) {
	for id := range m.removedreserves {
		ids = append(ids, id)
	}
	return
}

// ReservesIDs returns the reserves ids in the mutation.
func (m *CustomerMutation) ReservesIDs() (ids []int) {
	for id := range m.reserves {
		ids = append(ids, id)
	}
	return
}

// ResetReserves reset all changes of the "reserves" edge.
func (m *CustomerMutation) ResetReserves() {
	m.reserves = nil
	m.removedreserves = nil
}

// AddFixIDs adds the fixs edge to FixRoom by ids.
func (m *CustomerMutation) AddFixIDs(ids ...int) {
	if m.fixs == nil {
		m.fixs = make(map[int]struct{})
	}
	for i := range ids {
		m.fixs[ids[i]] = struct{}{}
	}
}

// RemoveFixIDs removes the fixs edge to FixRoom by ids.
func (m *CustomerMutation) RemoveFixIDs(ids ...int) {
	if m.removedfixs == nil {
		m.removedfixs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfixs[ids[i]] = struct{}{}
	}
}

// RemovedFixs returns the removed ids of fixs.
func (m *CustomerMutation) RemovedFixsIDs() (ids []int) {
	for id := range m.removedfixs {
		ids = append(ids, id)
	}
	return
}

// FixsIDs returns the fixs ids in the mutation.
func (m *CustomerMutation) FixsIDs() (ids []int) {
	for id := range m.fixs {
		ids = append(ids, id)
	}
	return
}

// ResetFixs reset all changes of the "fixs" edge.
func (m *CustomerMutation) ResetFixs() {
	m.fixs = nil
	m.removedfixs = nil
}

// AddCheckinIDs adds the checkins edge to CheckIn by ids.
func (m *CustomerMutation) AddCheckinIDs(ids ...int) {
	if m.checkins == nil {
		m.checkins = make(map[int]struct{})
	}
	for i := range ids {
		m.checkins[ids[i]] = struct{}{}
	}
}

// RemoveCheckinIDs removes the checkins edge to CheckIn by ids.
func (m *CustomerMutation) RemoveCheckinIDs(ids ...int) {
	if m.removedcheckins == nil {
		m.removedcheckins = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheckins[ids[i]] = struct{}{}
	}
}

// RemovedCheckins returns the removed ids of checkins.
func (m *CustomerMutation) RemovedCheckinsIDs() (ids []int) {
	for id := range m.removedcheckins {
		ids = append(ids, id)
	}
	return
}

// CheckinsIDs returns the checkins ids in the mutation.
func (m *CustomerMutation) CheckinsIDs() (ids []int) {
	for id := range m.checkins {
		ids = append(ids, id)
	}
	return
}

// ResetCheckins reset all changes of the "checkins" edge.
func (m *CustomerMutation) ResetCheckins() {
	m.checkins = nil
	m.removedcheckins = nil
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.email != nil {
		fields = append(fields, customer.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, customer.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldName:
		return m.Name()
	case customer.FieldEmail:
		return m.Email()
	case customer.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldEmail:
		return m.OldEmail(ctx)
	case customer.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customer.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CustomerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldEmail:
		m.ResetEmail()
		return nil
	case customer.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.reserves != nil {
		edges = append(edges, customer.EdgeReserves)
	}
	if m.fixs != nil {
		edges = append(edges, customer.EdgeFixs)
	}
	if m.checkins != nil {
		edges = append(edges, customer.EdgeCheckins)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeReserves:
		ids := make([]ent.Value, 0, len(m.reserves))
		for id := range m.reserves {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeFixs:
		ids := make([]ent.Value, 0, len(m.fixs))
		for id := range m.fixs {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCheckins:
		ids := make([]ent.Value, 0, len(m.checkins))
		for id := range m.checkins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreserves != nil {
		edges = append(edges, customer.EdgeReserves)
	}
	if m.removedfixs != nil {
		edges = append(edges, customer.EdgeFixs)
	}
	if m.removedcheckins != nil {
		edges = append(edges, customer.EdgeCheckins)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeReserves:
		ids := make([]ent.Value, 0, len(m.removedreserves))
		for id := range m.removedreserves {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeFixs:
		ids := make([]ent.Value, 0, len(m.removedfixs))
		for id := range m.removedfixs {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCheckins:
		ids := make([]ent.Value, 0, len(m.removedcheckins))
		for id := range m.removedcheckins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeReserves:
		m.ResetReserves()
		return nil
	case customer.EdgeFixs:
		m.ResetFixs()
		return nil
	case customer.EdgeCheckins:
		m.ResetCheckins()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// DataRoomMutation represents an operation that mutate the DataRooms
// nodes in the graph.
type DataRoomMutation struct {
	config
	op                Op
	typ               string
	id                *int
	price             *float64
	addprice          *float64
	roomnumber        *string
	clearedFields     map[string]struct{}
	reserves          map[int]struct{}
	removedreserves   map[int]struct{}
	fixs              map[int]struct{}
	removedfixs       map[int]struct{}
	details           map[int]struct{}
	removeddetails    map[int]struct{}
	checkins          map[int]struct{}
	removedcheckins   map[int]struct{}
	promotion         *int
	clearedpromotion  bool
	statusroom        *int
	clearedstatusroom bool
	typeroom          *int
	clearedtyperoom   bool
	done              bool
	oldValue          func(context.Context) (*DataRoom, error)
}

var _ ent.Mutation = (*DataRoomMutation)(nil)

// dataroomOption allows to manage the mutation configuration using functional options.
type dataroomOption func(*DataRoomMutation)

// newDataRoomMutation creates new mutation for $n.Name.
func newDataRoomMutation(c config, op Op, opts ...dataroomOption) *DataRoomMutation {
	m := &DataRoomMutation{
		config:        c,
		op:            op,
		typ:           TypeDataRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDataRoomID sets the id field of the mutation.
func withDataRoomID(id int) dataroomOption {
	return func(m *DataRoomMutation) {
		var (
			err   error
			once  sync.Once
			value *DataRoom
		)
		m.oldValue = func(ctx context.Context) (*DataRoom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DataRoom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDataRoom sets the old DataRoom of the mutation.
func withDataRoom(node *DataRoom) dataroomOption {
	return func(m *DataRoomMutation) {
		m.oldValue = func(context.Context) (*DataRoom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DataRoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DataRoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DataRoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrice sets the price field.
func (m *DataRoomMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the price value in the mutation.
func (m *DataRoomMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old price value of the DataRoom.
// If the DataRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DataRoomMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to price.
func (m *DataRoomMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the price field in this mutation.
func (m *DataRoomMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice reset all changes of the "price" field.
func (m *DataRoomMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetRoomnumber sets the roomnumber field.
func (m *DataRoomMutation) SetRoomnumber(s string) {
	m.roomnumber = &s
}

// Roomnumber returns the roomnumber value in the mutation.
func (m *DataRoomMutation) Roomnumber() (r string, exists bool) {
	v := m.roomnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomnumber returns the old roomnumber value of the DataRoom.
// If the DataRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DataRoomMutation) OldRoomnumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomnumber: %w", err)
	}
	return oldValue.Roomnumber, nil
}

// ResetRoomnumber reset all changes of the "roomnumber" field.
func (m *DataRoomMutation) ResetRoomnumber() {
	m.roomnumber = nil
}

// AddReserfIDs adds the reserves edge to ReserveRoom by ids.
func (m *DataRoomMutation) AddReserfIDs(ids ...int) {
	if m.reserves == nil {
		m.reserves = make(map[int]struct{})
	}
	for i := range ids {
		m.reserves[ids[i]] = struct{}{}
	}
}

// RemoveReserfIDs removes the reserves edge to ReserveRoom by ids.
func (m *DataRoomMutation) RemoveReserfIDs(ids ...int) {
	if m.removedreserves == nil {
		m.removedreserves = make(map[int]struct{})
	}
	for i := range ids {
		m.removedreserves[ids[i]] = struct{}{}
	}
}

// RemovedReserves returns the removed ids of reserves.
func (m *DataRoomMutation) RemovedReservesIDs() (ids []int) {
	for id := range m.removedreserves {
		ids = append(ids, id)
	}
	return
}

// ReservesIDs returns the reserves ids in the mutation.
func (m *DataRoomMutation) ReservesIDs() (ids []int) {
	for id := range m.reserves {
		ids = append(ids, id)
	}
	return
}

// ResetReserves reset all changes of the "reserves" edge.
func (m *DataRoomMutation) ResetReserves() {
	m.reserves = nil
	m.removedreserves = nil
}

// AddFixIDs adds the fixs edge to FixRoom by ids.
func (m *DataRoomMutation) AddFixIDs(ids ...int) {
	if m.fixs == nil {
		m.fixs = make(map[int]struct{})
	}
	for i := range ids {
		m.fixs[ids[i]] = struct{}{}
	}
}

// RemoveFixIDs removes the fixs edge to FixRoom by ids.
func (m *DataRoomMutation) RemoveFixIDs(ids ...int) {
	if m.removedfixs == nil {
		m.removedfixs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfixs[ids[i]] = struct{}{}
	}
}

// RemovedFixs returns the removed ids of fixs.
func (m *DataRoomMutation) RemovedFixsIDs() (ids []int) {
	for id := range m.removedfixs {
		ids = append(ids, id)
	}
	return
}

// FixsIDs returns the fixs ids in the mutation.
func (m *DataRoomMutation) FixsIDs() (ids []int) {
	for id := range m.fixs {
		ids = append(ids, id)
	}
	return
}

// ResetFixs reset all changes of the "fixs" edge.
func (m *DataRoomMutation) ResetFixs() {
	m.fixs = nil
	m.removedfixs = nil
}

// AddDetailIDs adds the details edge to FurnitureDetail by ids.
func (m *DataRoomMutation) AddDetailIDs(ids ...int) {
	if m.details == nil {
		m.details = make(map[int]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// RemoveDetailIDs removes the details edge to FurnitureDetail by ids.
func (m *DataRoomMutation) RemoveDetailIDs(ids ...int) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed ids of details.
func (m *DataRoomMutation) RemovedDetailsIDs() (ids []int) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the details ids in the mutation.
func (m *DataRoomMutation) DetailsIDs() (ids []int) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails reset all changes of the "details" edge.
func (m *DataRoomMutation) ResetDetails() {
	m.details = nil
	m.removeddetails = nil
}

// AddCheckinIDs adds the checkins edge to CheckIn by ids.
func (m *DataRoomMutation) AddCheckinIDs(ids ...int) {
	if m.checkins == nil {
		m.checkins = make(map[int]struct{})
	}
	for i := range ids {
		m.checkins[ids[i]] = struct{}{}
	}
}

// RemoveCheckinIDs removes the checkins edge to CheckIn by ids.
func (m *DataRoomMutation) RemoveCheckinIDs(ids ...int) {
	if m.removedcheckins == nil {
		m.removedcheckins = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheckins[ids[i]] = struct{}{}
	}
}

// RemovedCheckins returns the removed ids of checkins.
func (m *DataRoomMutation) RemovedCheckinsIDs() (ids []int) {
	for id := range m.removedcheckins {
		ids = append(ids, id)
	}
	return
}

// CheckinsIDs returns the checkins ids in the mutation.
func (m *DataRoomMutation) CheckinsIDs() (ids []int) {
	for id := range m.checkins {
		ids = append(ids, id)
	}
	return
}

// ResetCheckins reset all changes of the "checkins" edge.
func (m *DataRoomMutation) ResetCheckins() {
	m.checkins = nil
	m.removedcheckins = nil
}

// SetPromotionID sets the promotion edge to Promotion by id.
func (m *DataRoomMutation) SetPromotionID(id int) {
	m.promotion = &id
}

// ClearPromotion clears the promotion edge to Promotion.
func (m *DataRoomMutation) ClearPromotion() {
	m.clearedpromotion = true
}

// PromotionCleared returns if the edge promotion was cleared.
func (m *DataRoomMutation) PromotionCleared() bool {
	return m.clearedpromotion
}

// PromotionID returns the promotion id in the mutation.
func (m *DataRoomMutation) PromotionID() (id int, exists bool) {
	if m.promotion != nil {
		return *m.promotion, true
	}
	return
}

// PromotionIDs returns the promotion ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PromotionID instead. It exists only for internal usage by the builders.
func (m *DataRoomMutation) PromotionIDs() (ids []int) {
	if id := m.promotion; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPromotion reset all changes of the "promotion" edge.
func (m *DataRoomMutation) ResetPromotion() {
	m.promotion = nil
	m.clearedpromotion = false
}

// SetStatusroomID sets the statusroom edge to StatusRoom by id.
func (m *DataRoomMutation) SetStatusroomID(id int) {
	m.statusroom = &id
}

// ClearStatusroom clears the statusroom edge to StatusRoom.
func (m *DataRoomMutation) ClearStatusroom() {
	m.clearedstatusroom = true
}

// StatusroomCleared returns if the edge statusroom was cleared.
func (m *DataRoomMutation) StatusroomCleared() bool {
	return m.clearedstatusroom
}

// StatusroomID returns the statusroom id in the mutation.
func (m *DataRoomMutation) StatusroomID() (id int, exists bool) {
	if m.statusroom != nil {
		return *m.statusroom, true
	}
	return
}

// StatusroomIDs returns the statusroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatusroomID instead. It exists only for internal usage by the builders.
func (m *DataRoomMutation) StatusroomIDs() (ids []int) {
	if id := m.statusroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusroom reset all changes of the "statusroom" edge.
func (m *DataRoomMutation) ResetStatusroom() {
	m.statusroom = nil
	m.clearedstatusroom = false
}

// SetTyperoomID sets the typeroom edge to TypeRoom by id.
func (m *DataRoomMutation) SetTyperoomID(id int) {
	m.typeroom = &id
}

// ClearTyperoom clears the typeroom edge to TypeRoom.
func (m *DataRoomMutation) ClearTyperoom() {
	m.clearedtyperoom = true
}

// TyperoomCleared returns if the edge typeroom was cleared.
func (m *DataRoomMutation) TyperoomCleared() bool {
	return m.clearedtyperoom
}

// TyperoomID returns the typeroom id in the mutation.
func (m *DataRoomMutation) TyperoomID() (id int, exists bool) {
	if m.typeroom != nil {
		return *m.typeroom, true
	}
	return
}

// TyperoomIDs returns the typeroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TyperoomID instead. It exists only for internal usage by the builders.
func (m *DataRoomMutation) TyperoomIDs() (ids []int) {
	if id := m.typeroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTyperoom reset all changes of the "typeroom" edge.
func (m *DataRoomMutation) ResetTyperoom() {
	m.typeroom = nil
	m.clearedtyperoom = false
}

// Op returns the operation name.
func (m *DataRoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DataRoom).
func (m *DataRoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DataRoomMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.price != nil {
		fields = append(fields, dataroom.FieldPrice)
	}
	if m.roomnumber != nil {
		fields = append(fields, dataroom.FieldRoomnumber)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DataRoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dataroom.FieldPrice:
		return m.Price()
	case dataroom.FieldRoomnumber:
		return m.Roomnumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DataRoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dataroom.FieldPrice:
		return m.OldPrice(ctx)
	case dataroom.FieldRoomnumber:
		return m.OldRoomnumber(ctx)
	}
	return nil, fmt.Errorf("unknown DataRoom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DataRoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dataroom.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case dataroom.FieldRoomnumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomnumber(v)
		return nil
	}
	return fmt.Errorf("unknown DataRoom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DataRoomMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, dataroom.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DataRoomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dataroom.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DataRoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dataroom.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown DataRoom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DataRoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DataRoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DataRoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DataRoom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DataRoomMutation) ResetField(name string) error {
	switch name {
	case dataroom.FieldPrice:
		m.ResetPrice()
		return nil
	case dataroom.FieldRoomnumber:
		m.ResetRoomnumber()
		return nil
	}
	return fmt.Errorf("unknown DataRoom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DataRoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.reserves != nil {
		edges = append(edges, dataroom.EdgeReserves)
	}
	if m.fixs != nil {
		edges = append(edges, dataroom.EdgeFixs)
	}
	if m.details != nil {
		edges = append(edges, dataroom.EdgeDetails)
	}
	if m.checkins != nil {
		edges = append(edges, dataroom.EdgeCheckins)
	}
	if m.promotion != nil {
		edges = append(edges, dataroom.EdgePromotion)
	}
	if m.statusroom != nil {
		edges = append(edges, dataroom.EdgeStatusroom)
	}
	if m.typeroom != nil {
		edges = append(edges, dataroom.EdgeTyperoom)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DataRoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dataroom.EdgeReserves:
		ids := make([]ent.Value, 0, len(m.reserves))
		for id := range m.reserves {
			ids = append(ids, id)
		}
		return ids
	case dataroom.EdgeFixs:
		ids := make([]ent.Value, 0, len(m.fixs))
		for id := range m.fixs {
			ids = append(ids, id)
		}
		return ids
	case dataroom.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	case dataroom.EdgeCheckins:
		ids := make([]ent.Value, 0, len(m.checkins))
		for id := range m.checkins {
			ids = append(ids, id)
		}
		return ids
	case dataroom.EdgePromotion:
		if id := m.promotion; id != nil {
			return []ent.Value{*id}
		}
	case dataroom.EdgeStatusroom:
		if id := m.statusroom; id != nil {
			return []ent.Value{*id}
		}
	case dataroom.EdgeTyperoom:
		if id := m.typeroom; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DataRoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedreserves != nil {
		edges = append(edges, dataroom.EdgeReserves)
	}
	if m.removedfixs != nil {
		edges = append(edges, dataroom.EdgeFixs)
	}
	if m.removeddetails != nil {
		edges = append(edges, dataroom.EdgeDetails)
	}
	if m.removedcheckins != nil {
		edges = append(edges, dataroom.EdgeCheckins)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DataRoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dataroom.EdgeReserves:
		ids := make([]ent.Value, 0, len(m.removedreserves))
		for id := range m.removedreserves {
			ids = append(ids, id)
		}
		return ids
	case dataroom.EdgeFixs:
		ids := make([]ent.Value, 0, len(m.removedfixs))
		for id := range m.removedfixs {
			ids = append(ids, id)
		}
		return ids
	case dataroom.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	case dataroom.EdgeCheckins:
		ids := make([]ent.Value, 0, len(m.removedcheckins))
		for id := range m.removedcheckins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DataRoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedpromotion {
		edges = append(edges, dataroom.EdgePromotion)
	}
	if m.clearedstatusroom {
		edges = append(edges, dataroom.EdgeStatusroom)
	}
	if m.clearedtyperoom {
		edges = append(edges, dataroom.EdgeTyperoom)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DataRoomMutation) EdgeCleared(name string) bool {
	switch name {
	case dataroom.EdgePromotion:
		return m.clearedpromotion
	case dataroom.EdgeStatusroom:
		return m.clearedstatusroom
	case dataroom.EdgeTyperoom:
		return m.clearedtyperoom
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DataRoomMutation) ClearEdge(name string) error {
	switch name {
	case dataroom.EdgePromotion:
		m.ClearPromotion()
		return nil
	case dataroom.EdgeStatusroom:
		m.ClearStatusroom()
		return nil
	case dataroom.EdgeTyperoom:
		m.ClearTyperoom()
		return nil
	}
	return fmt.Errorf("unknown DataRoom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DataRoomMutation) ResetEdge(name string) error {
	switch name {
	case dataroom.EdgeReserves:
		m.ResetReserves()
		return nil
	case dataroom.EdgeFixs:
		m.ResetFixs()
		return nil
	case dataroom.EdgeDetails:
		m.ResetDetails()
		return nil
	case dataroom.EdgeCheckins:
		m.ResetCheckins()
		return nil
	case dataroom.EdgePromotion:
		m.ResetPromotion()
		return nil
	case dataroom.EdgeStatusroom:
		m.ResetStatusroom()
		return nil
	case dataroom.EdgeTyperoom:
		m.ResetTyperoom()
		return nil
	}
	return fmt.Errorf("unknown DataRoom edge %s", name)
}

// FixRoomMutation represents an operation that mutate the FixRooms
// nodes in the graph.
type FixRoomMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	fix_detail             *string
	clearedFields          map[string]struct{}
	customer               *int
	clearedcustomer        bool
	furnitureDetail        *int
	clearedfurnitureDetail bool
	room                   *int
	clearedroom            bool
	done                   bool
	oldValue               func(context.Context) (*FixRoom, error)
}

var _ ent.Mutation = (*FixRoomMutation)(nil)

// fixroomOption allows to manage the mutation configuration using functional options.
type fixroomOption func(*FixRoomMutation)

// newFixRoomMutation creates new mutation for $n.Name.
func newFixRoomMutation(c config, op Op, opts ...fixroomOption) *FixRoomMutation {
	m := &FixRoomMutation{
		config:        c,
		op:            op,
		typ:           TypeFixRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFixRoomID sets the id field of the mutation.
func withFixRoomID(id int) fixroomOption {
	return func(m *FixRoomMutation) {
		var (
			err   error
			once  sync.Once
			value *FixRoom
		)
		m.oldValue = func(ctx context.Context) (*FixRoom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FixRoom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFixRoom sets the old FixRoom of the mutation.
func withFixRoom(node *FixRoom) fixroomOption {
	return func(m *FixRoomMutation) {
		m.oldValue = func(context.Context) (*FixRoom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FixRoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FixRoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FixRoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFixDetail sets the fix_detail field.
func (m *FixRoomMutation) SetFixDetail(s string) {
	m.fix_detail = &s
}

// FixDetail returns the fix_detail value in the mutation.
func (m *FixRoomMutation) FixDetail() (r string, exists bool) {
	v := m.fix_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldFixDetail returns the old fix_detail value of the FixRoom.
// If the FixRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FixRoomMutation) OldFixDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFixDetail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFixDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixDetail: %w", err)
	}
	return oldValue.FixDetail, nil
}

// ResetFixDetail reset all changes of the "fix_detail" field.
func (m *FixRoomMutation) ResetFixDetail() {
	m.fix_detail = nil
}

// SetCustomerID sets the customer edge to Customer by id.
func (m *FixRoomMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the customer edge to Customer.
func (m *FixRoomMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared returns if the edge customer was cleared.
func (m *FixRoomMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the customer id in the mutation.
func (m *FixRoomMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the customer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *FixRoomMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer reset all changes of the "customer" edge.
func (m *FixRoomMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetFurnitureDetailID sets the furnitureDetail edge to FurnitureDetail by id.
func (m *FixRoomMutation) SetFurnitureDetailID(id int) {
	m.furnitureDetail = &id
}

// ClearFurnitureDetail clears the furnitureDetail edge to FurnitureDetail.
func (m *FixRoomMutation) ClearFurnitureDetail() {
	m.clearedfurnitureDetail = true
}

// FurnitureDetailCleared returns if the edge furnitureDetail was cleared.
func (m *FixRoomMutation) FurnitureDetailCleared() bool {
	return m.clearedfurnitureDetail
}

// FurnitureDetailID returns the furnitureDetail id in the mutation.
func (m *FixRoomMutation) FurnitureDetailID() (id int, exists bool) {
	if m.furnitureDetail != nil {
		return *m.furnitureDetail, true
	}
	return
}

// FurnitureDetailIDs returns the furnitureDetail ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FurnitureDetailID instead. It exists only for internal usage by the builders.
func (m *FixRoomMutation) FurnitureDetailIDs() (ids []int) {
	if id := m.furnitureDetail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFurnitureDetail reset all changes of the "furnitureDetail" edge.
func (m *FixRoomMutation) ResetFurnitureDetail() {
	m.furnitureDetail = nil
	m.clearedfurnitureDetail = false
}

// SetRoomID sets the room edge to DataRoom by id.
func (m *FixRoomMutation) SetRoomID(id int) {
	m.room = &id
}

// ClearRoom clears the room edge to DataRoom.
func (m *FixRoomMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared returns if the edge room was cleared.
func (m *FixRoomMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the room id in the mutation.
func (m *FixRoomMutation) RoomID() (id int, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the room ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *FixRoomMutation) RoomIDs() (ids []int) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom reset all changes of the "room" edge.
func (m *FixRoomMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// Op returns the operation name.
func (m *FixRoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FixRoom).
func (m *FixRoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FixRoomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.fix_detail != nil {
		fields = append(fields, fixroom.FieldFixDetail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FixRoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fixroom.FieldFixDetail:
		return m.FixDetail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FixRoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fixroom.FieldFixDetail:
		return m.OldFixDetail(ctx)
	}
	return nil, fmt.Errorf("unknown FixRoom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FixRoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fixroom.FieldFixDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixDetail(v)
		return nil
	}
	return fmt.Errorf("unknown FixRoom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FixRoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FixRoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FixRoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FixRoom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FixRoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FixRoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FixRoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FixRoom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FixRoomMutation) ResetField(name string) error {
	switch name {
	case fixroom.FieldFixDetail:
		m.ResetFixDetail()
		return nil
	}
	return fmt.Errorf("unknown FixRoom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FixRoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.customer != nil {
		edges = append(edges, fixroom.EdgeCustomer)
	}
	if m.furnitureDetail != nil {
		edges = append(edges, fixroom.EdgeFurnitureDetail)
	}
	if m.room != nil {
		edges = append(edges, fixroom.EdgeRoom)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FixRoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fixroom.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case fixroom.EdgeFurnitureDetail:
		if id := m.furnitureDetail; id != nil {
			return []ent.Value{*id}
		}
	case fixroom.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FixRoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FixRoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FixRoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcustomer {
		edges = append(edges, fixroom.EdgeCustomer)
	}
	if m.clearedfurnitureDetail {
		edges = append(edges, fixroom.EdgeFurnitureDetail)
	}
	if m.clearedroom {
		edges = append(edges, fixroom.EdgeRoom)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FixRoomMutation) EdgeCleared(name string) bool {
	switch name {
	case fixroom.EdgeCustomer:
		return m.clearedcustomer
	case fixroom.EdgeFurnitureDetail:
		return m.clearedfurnitureDetail
	case fixroom.EdgeRoom:
		return m.clearedroom
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FixRoomMutation) ClearEdge(name string) error {
	switch name {
	case fixroom.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case fixroom.EdgeFurnitureDetail:
		m.ClearFurnitureDetail()
		return nil
	case fixroom.EdgeRoom:
		m.ClearRoom()
		return nil
	}
	return fmt.Errorf("unknown FixRoom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FixRoomMutation) ResetEdge(name string) error {
	switch name {
	case fixroom.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case fixroom.EdgeFurnitureDetail:
		m.ResetFurnitureDetail()
		return nil
	case fixroom.EdgeRoom:
		m.ResetRoom()
		return nil
	}
	return fmt.Errorf("unknown FixRoom edge %s", name)
}

// FurnitureMutation represents an operation that mutate the Furnitures
// nodes in the graph.
type FurnitureMutation struct {
	config
	op             Op
	typ            string
	id             *int
	furniture_name *string
	clearedFields  map[string]struct{}
	details        map[int]struct{}
	removeddetails map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Furniture, error)
}

var _ ent.Mutation = (*FurnitureMutation)(nil)

// furnitureOption allows to manage the mutation configuration using functional options.
type furnitureOption func(*FurnitureMutation)

// newFurnitureMutation creates new mutation for $n.Name.
func newFurnitureMutation(c config, op Op, opts ...furnitureOption) *FurnitureMutation {
	m := &FurnitureMutation{
		config:        c,
		op:            op,
		typ:           TypeFurniture,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFurnitureID sets the id field of the mutation.
func withFurnitureID(id int) furnitureOption {
	return func(m *FurnitureMutation) {
		var (
			err   error
			once  sync.Once
			value *Furniture
		)
		m.oldValue = func(ctx context.Context) (*Furniture, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Furniture.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFurniture sets the old Furniture of the mutation.
func withFurniture(node *Furniture) furnitureOption {
	return func(m *FurnitureMutation) {
		m.oldValue = func(context.Context) (*Furniture, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FurnitureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FurnitureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FurnitureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFurnitureName sets the furniture_name field.
func (m *FurnitureMutation) SetFurnitureName(s string) {
	m.furniture_name = &s
}

// FurnitureName returns the furniture_name value in the mutation.
func (m *FurnitureMutation) FurnitureName() (r string, exists bool) {
	v := m.furniture_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFurnitureName returns the old furniture_name value of the Furniture.
// If the Furniture object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FurnitureMutation) OldFurnitureName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFurnitureName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFurnitureName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFurnitureName: %w", err)
	}
	return oldValue.FurnitureName, nil
}

// ResetFurnitureName reset all changes of the "furniture_name" field.
func (m *FurnitureMutation) ResetFurnitureName() {
	m.furniture_name = nil
}

// AddDetailIDs adds the details edge to FurnitureDetail by ids.
func (m *FurnitureMutation) AddDetailIDs(ids ...int) {
	if m.details == nil {
		m.details = make(map[int]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// RemoveDetailIDs removes the details edge to FurnitureDetail by ids.
func (m *FurnitureMutation) RemoveDetailIDs(ids ...int) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed ids of details.
func (m *FurnitureMutation) RemovedDetailsIDs() (ids []int) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the details ids in the mutation.
func (m *FurnitureMutation) DetailsIDs() (ids []int) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails reset all changes of the "details" edge.
func (m *FurnitureMutation) ResetDetails() {
	m.details = nil
	m.removeddetails = nil
}

// Op returns the operation name.
func (m *FurnitureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Furniture).
func (m *FurnitureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FurnitureMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.furniture_name != nil {
		fields = append(fields, furniture.FieldFurnitureName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FurnitureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case furniture.FieldFurnitureName:
		return m.FurnitureName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FurnitureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case furniture.FieldFurnitureName:
		return m.OldFurnitureName(ctx)
	}
	return nil, fmt.Errorf("unknown Furniture field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FurnitureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case furniture.FieldFurnitureName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFurnitureName(v)
		return nil
	}
	return fmt.Errorf("unknown Furniture field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FurnitureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FurnitureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FurnitureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Furniture numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FurnitureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FurnitureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FurnitureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Furniture nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FurnitureMutation) ResetField(name string) error {
	switch name {
	case furniture.FieldFurnitureName:
		m.ResetFurnitureName()
		return nil
	}
	return fmt.Errorf("unknown Furniture field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FurnitureMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.details != nil {
		edges = append(edges, furniture.EdgeDetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FurnitureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case furniture.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FurnitureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddetails != nil {
		edges = append(edges, furniture.EdgeDetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FurnitureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case furniture.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FurnitureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FurnitureMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FurnitureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Furniture unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FurnitureMutation) ResetEdge(name string) error {
	switch name {
	case furniture.EdgeDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Furniture edge %s", name)
}

// FurnitureDetailMutation represents an operation that mutate the FurnitureDetails
// nodes in the graph.
type FurnitureDetailMutation struct {
	config
	op                Op
	typ               string
	id                *int
	date_add          *time.Time
	clearedFields     map[string]struct{}
	fixs              map[int]struct{}
	removedfixs       map[int]struct{}
	furnitures        *int
	clearedfurnitures bool
	types             *int
	clearedtypes      bool
	rooms             *int
	clearedrooms      bool
	done              bool
	oldValue          func(context.Context) (*FurnitureDetail, error)
}

var _ ent.Mutation = (*FurnitureDetailMutation)(nil)

// furnituredetailOption allows to manage the mutation configuration using functional options.
type furnituredetailOption func(*FurnitureDetailMutation)

// newFurnitureDetailMutation creates new mutation for $n.Name.
func newFurnitureDetailMutation(c config, op Op, opts ...furnituredetailOption) *FurnitureDetailMutation {
	m := &FurnitureDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeFurnitureDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFurnitureDetailID sets the id field of the mutation.
func withFurnitureDetailID(id int) furnituredetailOption {
	return func(m *FurnitureDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *FurnitureDetail
		)
		m.oldValue = func(ctx context.Context) (*FurnitureDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FurnitureDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFurnitureDetail sets the old FurnitureDetail of the mutation.
func withFurnitureDetail(node *FurnitureDetail) furnituredetailOption {
	return func(m *FurnitureDetailMutation) {
		m.oldValue = func(context.Context) (*FurnitureDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FurnitureDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FurnitureDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FurnitureDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDateAdd sets the date_add field.
func (m *FurnitureDetailMutation) SetDateAdd(t time.Time) {
	m.date_add = &t
}

// DateAdd returns the date_add value in the mutation.
func (m *FurnitureDetailMutation) DateAdd() (r time.Time, exists bool) {
	v := m.date_add
	if v == nil {
		return
	}
	return *v, true
}

// OldDateAdd returns the old date_add value of the FurnitureDetail.
// If the FurnitureDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FurnitureDetailMutation) OldDateAdd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateAdd is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateAdd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateAdd: %w", err)
	}
	return oldValue.DateAdd, nil
}

// ResetDateAdd reset all changes of the "date_add" field.
func (m *FurnitureDetailMutation) ResetDateAdd() {
	m.date_add = nil
}

// AddFixIDs adds the fixs edge to FixRoom by ids.
func (m *FurnitureDetailMutation) AddFixIDs(ids ...int) {
	if m.fixs == nil {
		m.fixs = make(map[int]struct{})
	}
	for i := range ids {
		m.fixs[ids[i]] = struct{}{}
	}
}

// RemoveFixIDs removes the fixs edge to FixRoom by ids.
func (m *FurnitureDetailMutation) RemoveFixIDs(ids ...int) {
	if m.removedfixs == nil {
		m.removedfixs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfixs[ids[i]] = struct{}{}
	}
}

// RemovedFixs returns the removed ids of fixs.
func (m *FurnitureDetailMutation) RemovedFixsIDs() (ids []int) {
	for id := range m.removedfixs {
		ids = append(ids, id)
	}
	return
}

// FixsIDs returns the fixs ids in the mutation.
func (m *FurnitureDetailMutation) FixsIDs() (ids []int) {
	for id := range m.fixs {
		ids = append(ids, id)
	}
	return
}

// ResetFixs reset all changes of the "fixs" edge.
func (m *FurnitureDetailMutation) ResetFixs() {
	m.fixs = nil
	m.removedfixs = nil
}

// SetFurnituresID sets the furnitures edge to Furniture by id.
func (m *FurnitureDetailMutation) SetFurnituresID(id int) {
	m.furnitures = &id
}

// ClearFurnitures clears the furnitures edge to Furniture.
func (m *FurnitureDetailMutation) ClearFurnitures() {
	m.clearedfurnitures = true
}

// FurnituresCleared returns if the edge furnitures was cleared.
func (m *FurnitureDetailMutation) FurnituresCleared() bool {
	return m.clearedfurnitures
}

// FurnituresID returns the furnitures id in the mutation.
func (m *FurnitureDetailMutation) FurnituresID() (id int, exists bool) {
	if m.furnitures != nil {
		return *m.furnitures, true
	}
	return
}

// FurnituresIDs returns the furnitures ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FurnituresID instead. It exists only for internal usage by the builders.
func (m *FurnitureDetailMutation) FurnituresIDs() (ids []int) {
	if id := m.furnitures; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFurnitures reset all changes of the "furnitures" edge.
func (m *FurnitureDetailMutation) ResetFurnitures() {
	m.furnitures = nil
	m.clearedfurnitures = false
}

// SetTypesID sets the types edge to FurnitureType by id.
func (m *FurnitureDetailMutation) SetTypesID(id int) {
	m.types = &id
}

// ClearTypes clears the types edge to FurnitureType.
func (m *FurnitureDetailMutation) ClearTypes() {
	m.clearedtypes = true
}

// TypesCleared returns if the edge types was cleared.
func (m *FurnitureDetailMutation) TypesCleared() bool {
	return m.clearedtypes
}

// TypesID returns the types id in the mutation.
func (m *FurnitureDetailMutation) TypesID() (id int, exists bool) {
	if m.types != nil {
		return *m.types, true
	}
	return
}

// TypesIDs returns the types ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypesID instead. It exists only for internal usage by the builders.
func (m *FurnitureDetailMutation) TypesIDs() (ids []int) {
	if id := m.types; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTypes reset all changes of the "types" edge.
func (m *FurnitureDetailMutation) ResetTypes() {
	m.types = nil
	m.clearedtypes = false
}

// SetRoomsID sets the rooms edge to DataRoom by id.
func (m *FurnitureDetailMutation) SetRoomsID(id int) {
	m.rooms = &id
}

// ClearRooms clears the rooms edge to DataRoom.
func (m *FurnitureDetailMutation) ClearRooms() {
	m.clearedrooms = true
}

// RoomsCleared returns if the edge rooms was cleared.
func (m *FurnitureDetailMutation) RoomsCleared() bool {
	return m.clearedrooms
}

// RoomsID returns the rooms id in the mutation.
func (m *FurnitureDetailMutation) RoomsID() (id int, exists bool) {
	if m.rooms != nil {
		return *m.rooms, true
	}
	return
}

// RoomsIDs returns the rooms ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomsID instead. It exists only for internal usage by the builders.
func (m *FurnitureDetailMutation) RoomsIDs() (ids []int) {
	if id := m.rooms; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRooms reset all changes of the "rooms" edge.
func (m *FurnitureDetailMutation) ResetRooms() {
	m.rooms = nil
	m.clearedrooms = false
}

// Op returns the operation name.
func (m *FurnitureDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FurnitureDetail).
func (m *FurnitureDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FurnitureDetailMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.date_add != nil {
		fields = append(fields, furnituredetail.FieldDateAdd)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FurnitureDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case furnituredetail.FieldDateAdd:
		return m.DateAdd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FurnitureDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case furnituredetail.FieldDateAdd:
		return m.OldDateAdd(ctx)
	}
	return nil, fmt.Errorf("unknown FurnitureDetail field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FurnitureDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case furnituredetail.FieldDateAdd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateAdd(v)
		return nil
	}
	return fmt.Errorf("unknown FurnitureDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FurnitureDetailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FurnitureDetailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FurnitureDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FurnitureDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FurnitureDetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FurnitureDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FurnitureDetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FurnitureDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FurnitureDetailMutation) ResetField(name string) error {
	switch name {
	case furnituredetail.FieldDateAdd:
		m.ResetDateAdd()
		return nil
	}
	return fmt.Errorf("unknown FurnitureDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FurnitureDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.fixs != nil {
		edges = append(edges, furnituredetail.EdgeFixs)
	}
	if m.furnitures != nil {
		edges = append(edges, furnituredetail.EdgeFurnitures)
	}
	if m.types != nil {
		edges = append(edges, furnituredetail.EdgeTypes)
	}
	if m.rooms != nil {
		edges = append(edges, furnituredetail.EdgeRooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FurnitureDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case furnituredetail.EdgeFixs:
		ids := make([]ent.Value, 0, len(m.fixs))
		for id := range m.fixs {
			ids = append(ids, id)
		}
		return ids
	case furnituredetail.EdgeFurnitures:
		if id := m.furnitures; id != nil {
			return []ent.Value{*id}
		}
	case furnituredetail.EdgeTypes:
		if id := m.types; id != nil {
			return []ent.Value{*id}
		}
	case furnituredetail.EdgeRooms:
		if id := m.rooms; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FurnitureDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedfixs != nil {
		edges = append(edges, furnituredetail.EdgeFixs)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FurnitureDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case furnituredetail.EdgeFixs:
		ids := make([]ent.Value, 0, len(m.removedfixs))
		for id := range m.removedfixs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FurnitureDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedfurnitures {
		edges = append(edges, furnituredetail.EdgeFurnitures)
	}
	if m.clearedtypes {
		edges = append(edges, furnituredetail.EdgeTypes)
	}
	if m.clearedrooms {
		edges = append(edges, furnituredetail.EdgeRooms)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FurnitureDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case furnituredetail.EdgeFurnitures:
		return m.clearedfurnitures
	case furnituredetail.EdgeTypes:
		return m.clearedtypes
	case furnituredetail.EdgeRooms:
		return m.clearedrooms
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FurnitureDetailMutation) ClearEdge(name string) error {
	switch name {
	case furnituredetail.EdgeFurnitures:
		m.ClearFurnitures()
		return nil
	case furnituredetail.EdgeTypes:
		m.ClearTypes()
		return nil
	case furnituredetail.EdgeRooms:
		m.ClearRooms()
		return nil
	}
	return fmt.Errorf("unknown FurnitureDetail unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FurnitureDetailMutation) ResetEdge(name string) error {
	switch name {
	case furnituredetail.EdgeFixs:
		m.ResetFixs()
		return nil
	case furnituredetail.EdgeFurnitures:
		m.ResetFurnitures()
		return nil
	case furnituredetail.EdgeTypes:
		m.ResetTypes()
		return nil
	case furnituredetail.EdgeRooms:
		m.ResetRooms()
		return nil
	}
	return fmt.Errorf("unknown FurnitureDetail edge %s", name)
}

// FurnitureTypeMutation represents an operation that mutate the FurnitureTypes
// nodes in the graph.
type FurnitureTypeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	furniture_type *string
	clearedFields  map[string]struct{}
	details        map[int]struct{}
	removeddetails map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*FurnitureType, error)
}

var _ ent.Mutation = (*FurnitureTypeMutation)(nil)

// furnituretypeOption allows to manage the mutation configuration using functional options.
type furnituretypeOption func(*FurnitureTypeMutation)

// newFurnitureTypeMutation creates new mutation for $n.Name.
func newFurnitureTypeMutation(c config, op Op, opts ...furnituretypeOption) *FurnitureTypeMutation {
	m := &FurnitureTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeFurnitureType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFurnitureTypeID sets the id field of the mutation.
func withFurnitureTypeID(id int) furnituretypeOption {
	return func(m *FurnitureTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *FurnitureType
		)
		m.oldValue = func(ctx context.Context) (*FurnitureType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FurnitureType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFurnitureType sets the old FurnitureType of the mutation.
func withFurnitureType(node *FurnitureType) furnituretypeOption {
	return func(m *FurnitureTypeMutation) {
		m.oldValue = func(context.Context) (*FurnitureType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FurnitureTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FurnitureTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FurnitureTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFurnitureType sets the furniture_type field.
func (m *FurnitureTypeMutation) SetFurnitureType(s string) {
	m.furniture_type = &s
}

// FurnitureType returns the furniture_type value in the mutation.
func (m *FurnitureTypeMutation) FurnitureType() (r string, exists bool) {
	v := m.furniture_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFurnitureType returns the old furniture_type value of the FurnitureType.
// If the FurnitureType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FurnitureTypeMutation) OldFurnitureType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFurnitureType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFurnitureType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFurnitureType: %w", err)
	}
	return oldValue.FurnitureType, nil
}

// ResetFurnitureType reset all changes of the "furniture_type" field.
func (m *FurnitureTypeMutation) ResetFurnitureType() {
	m.furniture_type = nil
}

// AddDetailIDs adds the details edge to FurnitureDetail by ids.
func (m *FurnitureTypeMutation) AddDetailIDs(ids ...int) {
	if m.details == nil {
		m.details = make(map[int]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// RemoveDetailIDs removes the details edge to FurnitureDetail by ids.
func (m *FurnitureTypeMutation) RemoveDetailIDs(ids ...int) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed ids of details.
func (m *FurnitureTypeMutation) RemovedDetailsIDs() (ids []int) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the details ids in the mutation.
func (m *FurnitureTypeMutation) DetailsIDs() (ids []int) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails reset all changes of the "details" edge.
func (m *FurnitureTypeMutation) ResetDetails() {
	m.details = nil
	m.removeddetails = nil
}

// Op returns the operation name.
func (m *FurnitureTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FurnitureType).
func (m *FurnitureTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FurnitureTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.furniture_type != nil {
		fields = append(fields, furnituretype.FieldFurnitureType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FurnitureTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case furnituretype.FieldFurnitureType:
		return m.FurnitureType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FurnitureTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case furnituretype.FieldFurnitureType:
		return m.OldFurnitureType(ctx)
	}
	return nil, fmt.Errorf("unknown FurnitureType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FurnitureTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case furnituretype.FieldFurnitureType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFurnitureType(v)
		return nil
	}
	return fmt.Errorf("unknown FurnitureType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FurnitureTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FurnitureTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FurnitureTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FurnitureType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FurnitureTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FurnitureTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FurnitureTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FurnitureType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FurnitureTypeMutation) ResetField(name string) error {
	switch name {
	case furnituretype.FieldFurnitureType:
		m.ResetFurnitureType()
		return nil
	}
	return fmt.Errorf("unknown FurnitureType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FurnitureTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.details != nil {
		edges = append(edges, furnituretype.EdgeDetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FurnitureTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case furnituretype.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FurnitureTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddetails != nil {
		edges = append(edges, furnituretype.EdgeDetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FurnitureTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case furnituretype.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FurnitureTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FurnitureTypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FurnitureTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FurnitureType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FurnitureTypeMutation) ResetEdge(name string) error {
	switch name {
	case furnituretype.EdgeDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown FurnitureType edge %s", name)
}

// PromotionMutation represents an operation that mutate the Promotions
// nodes in the graph.
type PromotionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	promotion_name   *string
	discount         *float64
	adddiscount      *float64
	clearedFields    map[string]struct{}
	reserves         map[int]struct{}
	removedreserves  map[int]struct{}
	datarooms        map[int]struct{}
	removeddatarooms map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Promotion, error)
}

var _ ent.Mutation = (*PromotionMutation)(nil)

// promotionOption allows to manage the mutation configuration using functional options.
type promotionOption func(*PromotionMutation)

// newPromotionMutation creates new mutation for $n.Name.
func newPromotionMutation(c config, op Op, opts ...promotionOption) *PromotionMutation {
	m := &PromotionMutation{
		config:        c,
		op:            op,
		typ:           TypePromotion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionID sets the id field of the mutation.
func withPromotionID(id int) promotionOption {
	return func(m *PromotionMutation) {
		var (
			err   error
			once  sync.Once
			value *Promotion
		)
		m.oldValue = func(ctx context.Context) (*Promotion, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Promotion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotion sets the old Promotion of the mutation.
func withPromotion(node *Promotion) promotionOption {
	return func(m *PromotionMutation) {
		m.oldValue = func(context.Context) (*Promotion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PromotionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPromotionName sets the promotion_name field.
func (m *PromotionMutation) SetPromotionName(s string) {
	m.promotion_name = &s
}

// PromotionName returns the promotion_name value in the mutation.
func (m *PromotionMutation) PromotionName() (r string, exists bool) {
	v := m.promotion_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPromotionName returns the old promotion_name value of the Promotion.
// If the Promotion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PromotionMutation) OldPromotionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPromotionName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPromotionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromotionName: %w", err)
	}
	return oldValue.PromotionName, nil
}

// ResetPromotionName reset all changes of the "promotion_name" field.
func (m *PromotionMutation) ResetPromotionName() {
	m.promotion_name = nil
}

// SetDiscount sets the discount field.
func (m *PromotionMutation) SetDiscount(f float64) {
	m.discount = &f
	m.adddiscount = nil
}

// Discount returns the discount value in the mutation.
func (m *PromotionMutation) Discount() (r float64, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old discount value of the Promotion.
// If the Promotion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PromotionMutation) OldDiscount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// AddDiscount adds f to discount.
func (m *PromotionMutation) AddDiscount(f float64) {
	if m.adddiscount != nil {
		*m.adddiscount += f
	} else {
		m.adddiscount = &f
	}
}

// AddedDiscount returns the value that was added to the discount field in this mutation.
func (m *PromotionMutation) AddedDiscount() (r float64, exists bool) {
	v := m.adddiscount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscount reset all changes of the "discount" field.
func (m *PromotionMutation) ResetDiscount() {
	m.discount = nil
	m.adddiscount = nil
}

// AddReserfIDs adds the reserves edge to ReserveRoom by ids.
func (m *PromotionMutation) AddReserfIDs(ids ...int) {
	if m.reserves == nil {
		m.reserves = make(map[int]struct{})
	}
	for i := range ids {
		m.reserves[ids[i]] = struct{}{}
	}
}

// RemoveReserfIDs removes the reserves edge to ReserveRoom by ids.
func (m *PromotionMutation) RemoveReserfIDs(ids ...int) {
	if m.removedreserves == nil {
		m.removedreserves = make(map[int]struct{})
	}
	for i := range ids {
		m.removedreserves[ids[i]] = struct{}{}
	}
}

// RemovedReserves returns the removed ids of reserves.
func (m *PromotionMutation) RemovedReservesIDs() (ids []int) {
	for id := range m.removedreserves {
		ids = append(ids, id)
	}
	return
}

// ReservesIDs returns the reserves ids in the mutation.
func (m *PromotionMutation) ReservesIDs() (ids []int) {
	for id := range m.reserves {
		ids = append(ids, id)
	}
	return
}

// ResetReserves reset all changes of the "reserves" edge.
func (m *PromotionMutation) ResetReserves() {
	m.reserves = nil
	m.removedreserves = nil
}

// AddDataroomIDs adds the datarooms edge to DataRoom by ids.
func (m *PromotionMutation) AddDataroomIDs(ids ...int) {
	if m.datarooms == nil {
		m.datarooms = make(map[int]struct{})
	}
	for i := range ids {
		m.datarooms[ids[i]] = struct{}{}
	}
}

// RemoveDataroomIDs removes the datarooms edge to DataRoom by ids.
func (m *PromotionMutation) RemoveDataroomIDs(ids ...int) {
	if m.removeddatarooms == nil {
		m.removeddatarooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddatarooms[ids[i]] = struct{}{}
	}
}

// RemovedDatarooms returns the removed ids of datarooms.
func (m *PromotionMutation) RemovedDataroomsIDs() (ids []int) {
	for id := range m.removeddatarooms {
		ids = append(ids, id)
	}
	return
}

// DataroomsIDs returns the datarooms ids in the mutation.
func (m *PromotionMutation) DataroomsIDs() (ids []int) {
	for id := range m.datarooms {
		ids = append(ids, id)
	}
	return
}

// ResetDatarooms reset all changes of the "datarooms" edge.
func (m *PromotionMutation) ResetDatarooms() {
	m.datarooms = nil
	m.removeddatarooms = nil
}

// Op returns the operation name.
func (m *PromotionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Promotion).
func (m *PromotionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PromotionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.promotion_name != nil {
		fields = append(fields, promotion.FieldPromotionName)
	}
	if m.discount != nil {
		fields = append(fields, promotion.FieldDiscount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PromotionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotion.FieldPromotionName:
		return m.PromotionName()
	case promotion.FieldDiscount:
		return m.Discount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PromotionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotion.FieldPromotionName:
		return m.OldPromotionName(ctx)
	case promotion.FieldDiscount:
		return m.OldDiscount(ctx)
	}
	return nil, fmt.Errorf("unknown Promotion field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PromotionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotion.FieldPromotionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromotionName(v)
		return nil
	case promotion.FieldDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	}
	return fmt.Errorf("unknown Promotion field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PromotionMutation) AddedFields() []string {
	var fields []string
	if m.adddiscount != nil {
		fields = append(fields, promotion.FieldDiscount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PromotionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotion.FieldDiscount:
		return m.AddedDiscount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PromotionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotion.FieldDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscount(v)
		return nil
	}
	return fmt.Errorf("unknown Promotion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PromotionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PromotionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Promotion nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PromotionMutation) ResetField(name string) error {
	switch name {
	case promotion.FieldPromotionName:
		m.ResetPromotionName()
		return nil
	case promotion.FieldDiscount:
		m.ResetDiscount()
		return nil
	}
	return fmt.Errorf("unknown Promotion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PromotionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.reserves != nil {
		edges = append(edges, promotion.EdgeReserves)
	}
	if m.datarooms != nil {
		edges = append(edges, promotion.EdgeDatarooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PromotionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotion.EdgeReserves:
		ids := make([]ent.Value, 0, len(m.reserves))
		for id := range m.reserves {
			ids = append(ids, id)
		}
		return ids
	case promotion.EdgeDatarooms:
		ids := make([]ent.Value, 0, len(m.datarooms))
		for id := range m.datarooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PromotionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedreserves != nil {
		edges = append(edges, promotion.EdgeReserves)
	}
	if m.removeddatarooms != nil {
		edges = append(edges, promotion.EdgeDatarooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PromotionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promotion.EdgeReserves:
		ids := make([]ent.Value, 0, len(m.removedreserves))
		for id := range m.removedreserves {
			ids = append(ids, id)
		}
		return ids
	case promotion.EdgeDatarooms:
		ids := make([]ent.Value, 0, len(m.removeddatarooms))
		for id := range m.removeddatarooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PromotionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PromotionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PromotionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Promotion unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PromotionMutation) ResetEdge(name string) error {
	switch name {
	case promotion.EdgeReserves:
		m.ResetReserves()
		return nil
	case promotion.EdgeDatarooms:
		m.ResetDatarooms()
		return nil
	}
	return fmt.Errorf("unknown Promotion edge %s", name)
}

// ReserveRoomMutation represents an operation that mutate the ReserveRooms
// nodes in the graph.
type ReserveRoomMutation struct {
	config
	op               Op
	typ              string
	id               *int
	reserve_date     *time.Time
	date_out         *time.Time
	net_price        *float64
	addnet_price     *float64
	clearedFields    map[string]struct{}
	customer         *int
	clearedcustomer  bool
	promotion        *int
	clearedpromotion bool
	room             *int
	clearedroom      bool
	checkins         map[int]struct{}
	removedcheckins  map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*ReserveRoom, error)
}

var _ ent.Mutation = (*ReserveRoomMutation)(nil)

// reserveroomOption allows to manage the mutation configuration using functional options.
type reserveroomOption func(*ReserveRoomMutation)

// newReserveRoomMutation creates new mutation for $n.Name.
func newReserveRoomMutation(c config, op Op, opts ...reserveroomOption) *ReserveRoomMutation {
	m := &ReserveRoomMutation{
		config:        c,
		op:            op,
		typ:           TypeReserveRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReserveRoomID sets the id field of the mutation.
func withReserveRoomID(id int) reserveroomOption {
	return func(m *ReserveRoomMutation) {
		var (
			err   error
			once  sync.Once
			value *ReserveRoom
		)
		m.oldValue = func(ctx context.Context) (*ReserveRoom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReserveRoom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReserveRoom sets the old ReserveRoom of the mutation.
func withReserveRoom(node *ReserveRoom) reserveroomOption {
	return func(m *ReserveRoomMutation) {
		m.oldValue = func(context.Context) (*ReserveRoom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReserveRoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReserveRoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReserveRoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetReserveDate sets the reserve_date field.
func (m *ReserveRoomMutation) SetReserveDate(t time.Time) {
	m.reserve_date = &t
}

// ReserveDate returns the reserve_date value in the mutation.
func (m *ReserveRoomMutation) ReserveDate() (r time.Time, exists bool) {
	v := m.reserve_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReserveDate returns the old reserve_date value of the ReserveRoom.
// If the ReserveRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReserveRoomMutation) OldReserveDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReserveDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReserveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserveDate: %w", err)
	}
	return oldValue.ReserveDate, nil
}

// ResetReserveDate reset all changes of the "reserve_date" field.
func (m *ReserveRoomMutation) ResetReserveDate() {
	m.reserve_date = nil
}

// SetDateOut sets the date_out field.
func (m *ReserveRoomMutation) SetDateOut(t time.Time) {
	m.date_out = &t
}

// DateOut returns the date_out value in the mutation.
func (m *ReserveRoomMutation) DateOut() (r time.Time, exists bool) {
	v := m.date_out
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOut returns the old date_out value of the ReserveRoom.
// If the ReserveRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReserveRoomMutation) OldDateOut(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateOut is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOut: %w", err)
	}
	return oldValue.DateOut, nil
}

// ResetDateOut reset all changes of the "date_out" field.
func (m *ReserveRoomMutation) ResetDateOut() {
	m.date_out = nil
}

// SetNetPrice sets the net_price field.
func (m *ReserveRoomMutation) SetNetPrice(f float64) {
	m.net_price = &f
	m.addnet_price = nil
}

// NetPrice returns the net_price value in the mutation.
func (m *ReserveRoomMutation) NetPrice() (r float64, exists bool) {
	v := m.net_price
	if v == nil {
		return
	}
	return *v, true
}

// OldNetPrice returns the old net_price value of the ReserveRoom.
// If the ReserveRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReserveRoomMutation) OldNetPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNetPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNetPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetPrice: %w", err)
	}
	return oldValue.NetPrice, nil
}

// AddNetPrice adds f to net_price.
func (m *ReserveRoomMutation) AddNetPrice(f float64) {
	if m.addnet_price != nil {
		*m.addnet_price += f
	} else {
		m.addnet_price = &f
	}
}

// AddedNetPrice returns the value that was added to the net_price field in this mutation.
func (m *ReserveRoomMutation) AddedNetPrice() (r float64, exists bool) {
	v := m.addnet_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetNetPrice reset all changes of the "net_price" field.
func (m *ReserveRoomMutation) ResetNetPrice() {
	m.net_price = nil
	m.addnet_price = nil
}

// SetCustomerID sets the customer edge to Customer by id.
func (m *ReserveRoomMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the customer edge to Customer.
func (m *ReserveRoomMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared returns if the edge customer was cleared.
func (m *ReserveRoomMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the customer id in the mutation.
func (m *ReserveRoomMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the customer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *ReserveRoomMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer reset all changes of the "customer" edge.
func (m *ReserveRoomMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetPromotionID sets the promotion edge to Promotion by id.
func (m *ReserveRoomMutation) SetPromotionID(id int) {
	m.promotion = &id
}

// ClearPromotion clears the promotion edge to Promotion.
func (m *ReserveRoomMutation) ClearPromotion() {
	m.clearedpromotion = true
}

// PromotionCleared returns if the edge promotion was cleared.
func (m *ReserveRoomMutation) PromotionCleared() bool {
	return m.clearedpromotion
}

// PromotionID returns the promotion id in the mutation.
func (m *ReserveRoomMutation) PromotionID() (id int, exists bool) {
	if m.promotion != nil {
		return *m.promotion, true
	}
	return
}

// PromotionIDs returns the promotion ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PromotionID instead. It exists only for internal usage by the builders.
func (m *ReserveRoomMutation) PromotionIDs() (ids []int) {
	if id := m.promotion; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPromotion reset all changes of the "promotion" edge.
func (m *ReserveRoomMutation) ResetPromotion() {
	m.promotion = nil
	m.clearedpromotion = false
}

// SetRoomID sets the room edge to DataRoom by id.
func (m *ReserveRoomMutation) SetRoomID(id int) {
	m.room = &id
}

// ClearRoom clears the room edge to DataRoom.
func (m *ReserveRoomMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared returns if the edge room was cleared.
func (m *ReserveRoomMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the room id in the mutation.
func (m *ReserveRoomMutation) RoomID() (id int, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the room ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *ReserveRoomMutation) RoomIDs() (ids []int) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom reset all changes of the "room" edge.
func (m *ReserveRoomMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// AddCheckinIDs adds the checkins edge to CheckIn by ids.
func (m *ReserveRoomMutation) AddCheckinIDs(ids ...int) {
	if m.checkins == nil {
		m.checkins = make(map[int]struct{})
	}
	for i := range ids {
		m.checkins[ids[i]] = struct{}{}
	}
}

// RemoveCheckinIDs removes the checkins edge to CheckIn by ids.
func (m *ReserveRoomMutation) RemoveCheckinIDs(ids ...int) {
	if m.removedcheckins == nil {
		m.removedcheckins = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheckins[ids[i]] = struct{}{}
	}
}

// RemovedCheckins returns the removed ids of checkins.
func (m *ReserveRoomMutation) RemovedCheckinsIDs() (ids []int) {
	for id := range m.removedcheckins {
		ids = append(ids, id)
	}
	return
}

// CheckinsIDs returns the checkins ids in the mutation.
func (m *ReserveRoomMutation) CheckinsIDs() (ids []int) {
	for id := range m.checkins {
		ids = append(ids, id)
	}
	return
}

// ResetCheckins reset all changes of the "checkins" edge.
func (m *ReserveRoomMutation) ResetCheckins() {
	m.checkins = nil
	m.removedcheckins = nil
}

// Op returns the operation name.
func (m *ReserveRoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReserveRoom).
func (m *ReserveRoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReserveRoomMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.reserve_date != nil {
		fields = append(fields, reserveroom.FieldReserveDate)
	}
	if m.date_out != nil {
		fields = append(fields, reserveroom.FieldDateOut)
	}
	if m.net_price != nil {
		fields = append(fields, reserveroom.FieldNetPrice)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReserveRoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reserveroom.FieldReserveDate:
		return m.ReserveDate()
	case reserveroom.FieldDateOut:
		return m.DateOut()
	case reserveroom.FieldNetPrice:
		return m.NetPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReserveRoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reserveroom.FieldReserveDate:
		return m.OldReserveDate(ctx)
	case reserveroom.FieldDateOut:
		return m.OldDateOut(ctx)
	case reserveroom.FieldNetPrice:
		return m.OldNetPrice(ctx)
	}
	return nil, fmt.Errorf("unknown ReserveRoom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReserveRoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reserveroom.FieldReserveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserveDate(v)
		return nil
	case reserveroom.FieldDateOut:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOut(v)
		return nil
	case reserveroom.FieldNetPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ReserveRoom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReserveRoomMutation) AddedFields() []string {
	var fields []string
	if m.addnet_price != nil {
		fields = append(fields, reserveroom.FieldNetPrice)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReserveRoomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reserveroom.FieldNetPrice:
		return m.AddedNetPrice()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReserveRoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reserveroom.FieldNetPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ReserveRoom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReserveRoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReserveRoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReserveRoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReserveRoom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReserveRoomMutation) ResetField(name string) error {
	switch name {
	case reserveroom.FieldReserveDate:
		m.ResetReserveDate()
		return nil
	case reserveroom.FieldDateOut:
		m.ResetDateOut()
		return nil
	case reserveroom.FieldNetPrice:
		m.ResetNetPrice()
		return nil
	}
	return fmt.Errorf("unknown ReserveRoom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReserveRoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.customer != nil {
		edges = append(edges, reserveroom.EdgeCustomer)
	}
	if m.promotion != nil {
		edges = append(edges, reserveroom.EdgePromotion)
	}
	if m.room != nil {
		edges = append(edges, reserveroom.EdgeRoom)
	}
	if m.checkins != nil {
		edges = append(edges, reserveroom.EdgeCheckins)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReserveRoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reserveroom.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case reserveroom.EdgePromotion:
		if id := m.promotion; id != nil {
			return []ent.Value{*id}
		}
	case reserveroom.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	case reserveroom.EdgeCheckins:
		ids := make([]ent.Value, 0, len(m.checkins))
		for id := range m.checkins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReserveRoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcheckins != nil {
		edges = append(edges, reserveroom.EdgeCheckins)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReserveRoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case reserveroom.EdgeCheckins:
		ids := make([]ent.Value, 0, len(m.removedcheckins))
		for id := range m.removedcheckins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReserveRoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcustomer {
		edges = append(edges, reserveroom.EdgeCustomer)
	}
	if m.clearedpromotion {
		edges = append(edges, reserveroom.EdgePromotion)
	}
	if m.clearedroom {
		edges = append(edges, reserveroom.EdgeRoom)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReserveRoomMutation) EdgeCleared(name string) bool {
	switch name {
	case reserveroom.EdgeCustomer:
		return m.clearedcustomer
	case reserveroom.EdgePromotion:
		return m.clearedpromotion
	case reserveroom.EdgeRoom:
		return m.clearedroom
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReserveRoomMutation) ClearEdge(name string) error {
	switch name {
	case reserveroom.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case reserveroom.EdgePromotion:
		m.ClearPromotion()
		return nil
	case reserveroom.EdgeRoom:
		m.ClearRoom()
		return nil
	}
	return fmt.Errorf("unknown ReserveRoom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReserveRoomMutation) ResetEdge(name string) error {
	switch name {
	case reserveroom.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case reserveroom.EdgePromotion:
		m.ResetPromotion()
		return nil
	case reserveroom.EdgeRoom:
		m.ResetRoom()
		return nil
	case reserveroom.EdgeCheckins:
		m.ResetCheckins()
		return nil
	}
	return fmt.Errorf("unknown ReserveRoom edge %s", name)
}

// StatusMutation represents an operation that mutate the StatusSlice
// nodes in the graph.
type StatusMutation struct {
	config
	op               Op
	typ              string
	id               *int
	description      *string
	clearedFields    map[string]struct{}
	checkouts        map[int]struct{}
	removedcheckouts map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Status, error)
}

var _ ent.Mutation = (*StatusMutation)(nil)

// statusOption allows to manage the mutation configuration using functional options.
type statusOption func(*StatusMutation)

// newStatusMutation creates new mutation for $n.Name.
func newStatusMutation(c config, op Op, opts ...statusOption) *StatusMutation {
	m := &StatusMutation{
		config:        c,
		op:            op,
		typ:           TypeStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusID sets the id field of the mutation.
func withStatusID(id int) statusOption {
	return func(m *StatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Status
		)
		m.oldValue = func(ctx context.Context) (*Status, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Status.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatus sets the old Status of the mutation.
func withStatus(node *Status) statusOption {
	return func(m *StatusMutation) {
		m.oldValue = func(context.Context) (*Status, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDescription sets the description field.
func (m *StatusMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *StatusMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Status.
// If the Status object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *StatusMutation) ResetDescription() {
	m.description = nil
}

// AddCheckoutIDs adds the checkouts edge to Checkout by ids.
func (m *StatusMutation) AddCheckoutIDs(ids ...int) {
	if m.checkouts == nil {
		m.checkouts = make(map[int]struct{})
	}
	for i := range ids {
		m.checkouts[ids[i]] = struct{}{}
	}
}

// RemoveCheckoutIDs removes the checkouts edge to Checkout by ids.
func (m *StatusMutation) RemoveCheckoutIDs(ids ...int) {
	if m.removedcheckouts == nil {
		m.removedcheckouts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheckouts[ids[i]] = struct{}{}
	}
}

// RemovedCheckouts returns the removed ids of checkouts.
func (m *StatusMutation) RemovedCheckoutsIDs() (ids []int) {
	for id := range m.removedcheckouts {
		ids = append(ids, id)
	}
	return
}

// CheckoutsIDs returns the checkouts ids in the mutation.
func (m *StatusMutation) CheckoutsIDs() (ids []int) {
	for id := range m.checkouts {
		ids = append(ids, id)
	}
	return
}

// ResetCheckouts reset all changes of the "checkouts" edge.
func (m *StatusMutation) ResetCheckouts() {
	m.checkouts = nil
	m.removedcheckouts = nil
}

// Op returns the operation name.
func (m *StatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Status).
func (m *StatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.description != nil {
		fields = append(fields, status.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case status.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case status.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Status field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case status.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Status numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Status nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatusMutation) ResetField(name string) error {
	switch name {
	case status.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.checkouts != nil {
		edges = append(edges, status.EdgeCheckouts)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeCheckouts:
		ids := make([]ent.Value, 0, len(m.checkouts))
		for id := range m.checkouts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcheckouts != nil {
		edges = append(edges, status.EdgeCheckouts)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeCheckouts:
		ids := make([]ent.Value, 0, len(m.removedcheckouts))
		for id := range m.removedcheckouts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatusMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Status unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatusMutation) ResetEdge(name string) error {
	switch name {
	case status.EdgeCheckouts:
		m.ResetCheckouts()
		return nil
	}
	return fmt.Errorf("unknown Status edge %s", name)
}

// StatusRoomMutation represents an operation that mutate the StatusRooms
// nodes in the graph.
type StatusRoomMutation struct {
	config
	op               Op
	typ              string
	id               *int
	status_name      *string
	clearedFields    map[string]struct{}
	datarooms        map[int]struct{}
	removeddatarooms map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*StatusRoom, error)
}

var _ ent.Mutation = (*StatusRoomMutation)(nil)

// statusroomOption allows to manage the mutation configuration using functional options.
type statusroomOption func(*StatusRoomMutation)

// newStatusRoomMutation creates new mutation for $n.Name.
func newStatusRoomMutation(c config, op Op, opts ...statusroomOption) *StatusRoomMutation {
	m := &StatusRoomMutation{
		config:        c,
		op:            op,
		typ:           TypeStatusRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusRoomID sets the id field of the mutation.
func withStatusRoomID(id int) statusroomOption {
	return func(m *StatusRoomMutation) {
		var (
			err   error
			once  sync.Once
			value *StatusRoom
		)
		m.oldValue = func(ctx context.Context) (*StatusRoom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatusRoom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatusRoom sets the old StatusRoom of the mutation.
func withStatusRoom(node *StatusRoom) statusroomOption {
	return func(m *StatusRoomMutation) {
		m.oldValue = func(context.Context) (*StatusRoom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusRoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusRoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatusRoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatusName sets the status_name field.
func (m *StatusRoomMutation) SetStatusName(s string) {
	m.status_name = &s
}

// StatusName returns the status_name value in the mutation.
func (m *StatusRoomMutation) StatusName() (r string, exists bool) {
	v := m.status_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusName returns the old status_name value of the StatusRoom.
// If the StatusRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusRoomMutation) OldStatusName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusName: %w", err)
	}
	return oldValue.StatusName, nil
}

// ResetStatusName reset all changes of the "status_name" field.
func (m *StatusRoomMutation) ResetStatusName() {
	m.status_name = nil
}

// AddDataroomIDs adds the datarooms edge to DataRoom by ids.
func (m *StatusRoomMutation) AddDataroomIDs(ids ...int) {
	if m.datarooms == nil {
		m.datarooms = make(map[int]struct{})
	}
	for i := range ids {
		m.datarooms[ids[i]] = struct{}{}
	}
}

// RemoveDataroomIDs removes the datarooms edge to DataRoom by ids.
func (m *StatusRoomMutation) RemoveDataroomIDs(ids ...int) {
	if m.removeddatarooms == nil {
		m.removeddatarooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddatarooms[ids[i]] = struct{}{}
	}
}

// RemovedDatarooms returns the removed ids of datarooms.
func (m *StatusRoomMutation) RemovedDataroomsIDs() (ids []int) {
	for id := range m.removeddatarooms {
		ids = append(ids, id)
	}
	return
}

// DataroomsIDs returns the datarooms ids in the mutation.
func (m *StatusRoomMutation) DataroomsIDs() (ids []int) {
	for id := range m.datarooms {
		ids = append(ids, id)
	}
	return
}

// ResetDatarooms reset all changes of the "datarooms" edge.
func (m *StatusRoomMutation) ResetDatarooms() {
	m.datarooms = nil
	m.removeddatarooms = nil
}

// Op returns the operation name.
func (m *StatusRoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StatusRoom).
func (m *StatusRoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatusRoomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.status_name != nil {
		fields = append(fields, statusroom.FieldStatusName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatusRoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statusroom.FieldStatusName:
		return m.StatusName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatusRoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statusroom.FieldStatusName:
		return m.OldStatusName(ctx)
	}
	return nil, fmt.Errorf("unknown StatusRoom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusRoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statusroom.FieldStatusName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusName(v)
		return nil
	}
	return fmt.Errorf("unknown StatusRoom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatusRoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatusRoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusRoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StatusRoom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatusRoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatusRoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusRoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StatusRoom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatusRoomMutation) ResetField(name string) error {
	switch name {
	case statusroom.FieldStatusName:
		m.ResetStatusName()
		return nil
	}
	return fmt.Errorf("unknown StatusRoom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatusRoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.datarooms != nil {
		edges = append(edges, statusroom.EdgeDatarooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatusRoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statusroom.EdgeDatarooms:
		ids := make([]ent.Value, 0, len(m.datarooms))
		for id := range m.datarooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatusRoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddatarooms != nil {
		edges = append(edges, statusroom.EdgeDatarooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatusRoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statusroom.EdgeDatarooms:
		ids := make([]ent.Value, 0, len(m.removeddatarooms))
		for id := range m.removeddatarooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatusRoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatusRoomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatusRoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown StatusRoom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatusRoomMutation) ResetEdge(name string) error {
	switch name {
	case statusroom.EdgeDatarooms:
		m.ResetDatarooms()
		return nil
	}
	return fmt.Errorf("unknown StatusRoom edge %s", name)
}

// TypeRoomMutation represents an operation that mutate the TypeRooms
// nodes in the graph.
type TypeRoomMutation struct {
	config
	op               Op
	typ              string
	id               *int
	type_name        *string
	clearedFields    map[string]struct{}
	datarooms        map[int]struct{}
	removeddatarooms map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*TypeRoom, error)
}

var _ ent.Mutation = (*TypeRoomMutation)(nil)

// typeroomOption allows to manage the mutation configuration using functional options.
type typeroomOption func(*TypeRoomMutation)

// newTypeRoomMutation creates new mutation for $n.Name.
func newTypeRoomMutation(c config, op Op, opts ...typeroomOption) *TypeRoomMutation {
	m := &TypeRoomMutation{
		config:        c,
		op:            op,
		typ:           TypeTypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTypeRoomID sets the id field of the mutation.
func withTypeRoomID(id int) typeroomOption {
	return func(m *TypeRoomMutation) {
		var (
			err   error
			once  sync.Once
			value *TypeRoom
		)
		m.oldValue = func(ctx context.Context) (*TypeRoom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TypeRoom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTypeRoom sets the old TypeRoom of the mutation.
func withTypeRoom(node *TypeRoom) typeroomOption {
	return func(m *TypeRoomMutation) {
		m.oldValue = func(context.Context) (*TypeRoom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TypeRoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TypeRoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TypeRoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTypeName sets the type_name field.
func (m *TypeRoomMutation) SetTypeName(s string) {
	m.type_name = &s
}

// TypeName returns the type_name value in the mutation.
func (m *TypeRoomMutation) TypeName() (r string, exists bool) {
	v := m.type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old type_name value of the TypeRoom.
// If the TypeRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TypeRoomMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName reset all changes of the "type_name" field.
func (m *TypeRoomMutation) ResetTypeName() {
	m.type_name = nil
}

// AddDataroomIDs adds the datarooms edge to DataRoom by ids.
func (m *TypeRoomMutation) AddDataroomIDs(ids ...int) {
	if m.datarooms == nil {
		m.datarooms = make(map[int]struct{})
	}
	for i := range ids {
		m.datarooms[ids[i]] = struct{}{}
	}
}

// RemoveDataroomIDs removes the datarooms edge to DataRoom by ids.
func (m *TypeRoomMutation) RemoveDataroomIDs(ids ...int) {
	if m.removeddatarooms == nil {
		m.removeddatarooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddatarooms[ids[i]] = struct{}{}
	}
}

// RemovedDatarooms returns the removed ids of datarooms.
func (m *TypeRoomMutation) RemovedDataroomsIDs() (ids []int) {
	for id := range m.removeddatarooms {
		ids = append(ids, id)
	}
	return
}

// DataroomsIDs returns the datarooms ids in the mutation.
func (m *TypeRoomMutation) DataroomsIDs() (ids []int) {
	for id := range m.datarooms {
		ids = append(ids, id)
	}
	return
}

// ResetDatarooms reset all changes of the "datarooms" edge.
func (m *TypeRoomMutation) ResetDatarooms() {
	m.datarooms = nil
	m.removeddatarooms = nil
}

// Op returns the operation name.
func (m *TypeRoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TypeRoom).
func (m *TypeRoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TypeRoomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.type_name != nil {
		fields = append(fields, typeroom.FieldTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TypeRoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case typeroom.FieldTypeName:
		return m.TypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TypeRoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case typeroom.FieldTypeName:
		return m.OldTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown TypeRoom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TypeRoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case typeroom.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown TypeRoom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TypeRoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TypeRoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TypeRoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TypeRoom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TypeRoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TypeRoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TypeRoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TypeRoom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TypeRoomMutation) ResetField(name string) error {
	switch name {
	case typeroom.FieldTypeName:
		m.ResetTypeName()
		return nil
	}
	return fmt.Errorf("unknown TypeRoom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TypeRoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.datarooms != nil {
		edges = append(edges, typeroom.EdgeDatarooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TypeRoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case typeroom.EdgeDatarooms:
		ids := make([]ent.Value, 0, len(m.datarooms))
		for id := range m.datarooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TypeRoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddatarooms != nil {
		edges = append(edges, typeroom.EdgeDatarooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TypeRoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case typeroom.EdgeDatarooms:
		ids := make([]ent.Value, 0, len(m.removeddatarooms))
		for id := range m.removeddatarooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TypeRoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TypeRoomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TypeRoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TypeRoom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TypeRoomMutation) ResetEdge(name string) error {
	switch name {
	case typeroom.EdgeDatarooms:
		m.ResetDatarooms()
		return nil
	}
	return fmt.Errorf("unknown TypeRoom edge %s", name)
}
